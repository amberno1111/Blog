# 哈希表

在讨论哈希表之前，先来了解下其他数据结构在插入、删除、查找方面的性能：
- 数组：采用一段连续的内存空间来存储数据
    - 根据数组下标查找数据，时间复杂度O(1)；根据给定值查找数据，需要遍历数组，时间复杂度O(N)；如果是有序数组，可以用二分查找等方式，把时间复杂度降低到O(logN)
    - 插入和删除操作，涉及到数组元素的移动，时间复杂度都是O(N)
- 链表：采用不连续的节点来存储数据
    - 查找操作需要遍历整个链表，时间复杂度O(N)
    - 插入和删除操作，只需要改变节数据中指向前驱节点和后置节点的指针，时间复杂度O(1)
- 二叉树：以树形的结构排列节点来存储数据，查找、插入、删除操作的时间复杂度都是O(logN)

**哈希表的性能比上述几种数据结构都要高一些，它的查找、插入、删除操作的时间复杂度都是O(1)**。哈希表非常好的利用了数组的通过下标查找效率非常高的特性，它的实现就是利用一个数组和一个哈希函数，向哈希表中插入数据时，通过哈希函数计算出这个数据可以放到数组的哪个下标的位置上，然后把数据存入到数组中的这个目标位置。查找和删除操作同理，所以他们的时间复杂度都是O(1)。

但是哈希表也不是没有缺点，那就是可能会出现**哈希冲突**，也就是可能会出现几个数据，经过哈希函数的计算之后得到的结果(数组下标的值)是相同的，这时候就出现了冲突。一般来说，我们可以通过**链地址法、开放定址法(发现冲突、继续寻找下一块未被占用的内存)、再散列函数法等等算法来解决哈希冲突的问题。**







