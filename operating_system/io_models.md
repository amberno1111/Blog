# I/O模型

在开始介绍I/O模型之前，有一些基础的概念需要先解释下。

### 0. 同步、异步、阻塞、非阻塞

首先，同步vs异步和阻塞vs非阻塞可以分为两组概念，这两个概念所关注的重点是不一样的。

**同步vs异步**

同步和异步关注的是消息通信机制。

* 所谓的同步，是在发出一个调用时，在没有得到结果之前，该调用就不返回，但是一旦调用返回就可以直接得到结果。也就是说，调用方在主动等待这个调用的结果。
* 异步则与同步相反，是在发出一个调用之后，这个调用马上就返回，但是没有返回结果。然后被调用者之后通过状态、通知来告诉通知调用者，或者通过回调函数处理这个调用。

**阻塞vs非阻塞**

阻塞和非阻塞关注的是进程or线程在等待调用结果时的状态。

* 阻塞调用是指在调用结果返回之前，当前线程or进程会被挂起，无法继续之后的操作，这个线程只有在得到调用结果之后才会返回。
* 非阻塞是指在调用结果返回之前，当前线程能够继续执行后续的操作，而不会被挂起。

### 1. 程序空间与内核空间

操作系统为了支持多个应用的运行，需要保证不同的进程之间相对独立\(一个进程的崩溃不会影响其他的进程，恶意进程不能直接读取和修改其他进程运行时的代码和数据\)。因此，操作系统内核需要拥有高于普通进程的全信啊，以此来调度和管理用户的应用程序。

所以操作系统内核将内存空间分为两部分，一部分为内核空间，一部分为程序空间。内核空间存储的代码和数据拥有更高的权限，内存访问的相关硬件会在程序执行之时进行访问控制，使得用户程序不能直接读写内核空间的内存。

### 进程切换

* 当一个进程在运行时，中断\(interrupt\)和系统调用\(system call\)都会使得CPU的控制权从当前进程转移到操作系统内核。
* 进程切换时，操作系统内核会保留被切换的进程的上下文，然后取出另一个进程的上下文，并且把CPU控制权转让给这个进程。

**系统调用**

系统调用就是应用程序调用操作系统提供的接口来实现某些操作，比如硬盘、网络接口设备的读写等等。

### 进程阻塞

当一个进程发起了一个系统调用时，这个调用没有立即返回，而是等待了一段时间之后才能返回结果。而这个时候内核会将进程挂起，确保它不会占用CPU资源。

### I/O的阻塞与非阻塞

应用程序的I/O操作都是需要通过系统调用实现的。

* 阻塞I/O：当一个应用程序进程进行I/O操作的的系统调用时，比如读写磁盘或者网络的这种操作，都是不能立即完成的。这之后应用程序会一直等着这个调用的返回，内核就会将这个进程挂起，这时候进程就被阻塞了。
* 非阻塞I/O：当一个应用程序进程进行I/O操作的的系统调用时，内核会立即返回一个值\(不是调用结果，往往是一个标识符这样的值\)，然后进程就可以继续执行了，这时候进程不会被挂起，也就是不会被阻塞了。

大部分的操作系统默认给用户应用程序提供的都是阻塞式的系统调用接口，因为阻塞式的调用可以使得应用程序的代码编写更容易。

### I/O的同步与异步

* 同步I/O：应用程序发起系统调用，然后主动等待执行结果的返回
* 异步I/O：应用程序发起系统调用，内核立刻返回一个非执行结果的值，内核等到操作完成之后通过状态等方式通知应用程序

### 磁盘I/O与网络I/O

在系统中，I/O主要分为磁盘I/O与网络I/O两种，本篇文章主要讲网络I/O。一次完整的服务端处理网络请求的流程图如下：

![566545-20190222001419447-1786828034](https://user-images.githubusercontent.com/16413289/57978628-e4b55f80-7a43-11e9-9eba-a578dea8b011.png)

从上图中看到，无论是网络读\(recvfrom\)还是写\(sendto\)，数据都是需要经过内核空间的。从磁盘读写数据其实也一样的。

## 5种I/O模型

这时候我们再来看在Linux系统中提供的5种I/O模型，分别是：

* 阻塞I/O\(blocking I/O\)
* 非阻塞I/O\(nonblocking I/O\)
* I/O多路复用\(I/O multiplexing\)
* 信号驱动式I/O\(signal driven I/O\)
* 异步I/O\(asynchronous I/O\)

### 阻塞I/O

阻塞I/O模型如下图所示：当应用程序进行`recvform`系统调用的时候，应用程序将被阻塞在这个调用，**直到数据返回并且被复制到应用程序进程的缓冲区或者发生错误时才返回**，即_应用程序进程在调用recvfrom开始到recvfrom返回的整段时间内都是被阻塞的_。

![blockingIO](https://user-images.githubusercontent.com/16413289/57979103-62309e00-7a4b-11e9-8d6a-75b569092be4.png)

从上图来看，当应用程序进程调用了`recvfrom`这个系统调用，就开始block：

* 首先内核就开始I/O的第一个阶段，数据准备：对于网络IO来说，很多时候数据在一开始还没有到达，比如，还没有收到一个完整的UDP包，这个时候内核就要等待足够的数据到来。
* 当内核一直到等待到数据都准备好了，就把数据从内核空间copy到用户空间，然后内核返回结果，应用程序进程解除block状态，重新开始运行。

#### 特点

1. 这种模型的编程很简单，所以系统默认提供的都是阻塞I/O
2. 缺点是：如果socket上没有数据，进程将一直阻塞，这时候其他套接字上有数据也无法及时处理。

### 非阻塞I/O

非阻塞I/O模型如下图所示：当应用程序进程每次调用`recvfrom`的时候，如果数据还没准备好，系统就会返回错误信息，这样应用程序进程就不会block住，而是继续往后执行。

![nonblocking](https://user-images.githubusercontent.com/16413289/57979508-1aad1080-7a51-11e9-8185-a02cbf5df4b5.png)

#### 特点

1. 这种模型相对来说也简单，进程不会阻塞
2. 缺点就是需要频繁的轮询，会比较耗费资源，在并发量很大的时候将会花费大量的时间在没有任何数据的socket上轮询
3. 实际上这种模型在把数据从内核空间copy到程序空间的这个过程中依然是阻塞的

### I/O多路复用

I/O多路复用模型如下图所示：应用程序进程先调用`select`/`poll`/`epoll`等系统函数等待某个连接变成可读\(有数据过来\)，再调用`recvfrom`从连接上读取数据。这个模型其实**在两个阶段都会block**，但与阻塞I/O模型不同的是它的第一步阻塞在**等待多个连接上有读/写事件的发生上，明显的提高了效率并增加了单线程/单进程种并行处理多连接的可能**。

![IOmultiplexing](https://user-images.githubusercontent.com/16413289/57979498-079a4080-7a51-11e9-9843-88d8a8c18d14.png)

#### 特点

1. 可以统一管理连接，不一定采用多线程的方式，同时也不需要轮询，只需要阻塞与select即可
2. 缺点是当`select`/`poll`/`epoll`管理的连接数过少的时候，这种模型会退化为阻塞I/O模型，并且还多了一次系统调用

### 信号驱动I/O模型

信号驱动I/O模型如下图所示：应用程序进程只负责创建SIGIO的信号处理程序，这个处理程序可以处理连接上数据的读写和业务处理。然后应用程序进程可以往下执行，当内核数据准备好时会向应用进程发送四年好，触发信号处理程序的执行，再再信号处理程序种进行`recvfrom`和业务处理。

![signal-drivenIO](https://user-images.githubusercontent.com/16413289/57979514-2c8eb380-7a51-11e9-8e66-b038f44def80.png)

#### 特点

1. 非阻塞
2. 缺点是在前一个信号没被处理的情况下，后面一个信号来了也不能被处理。所以在信号量大的时候会导致后面的信号不能及时被感知

### 异步I/O模型

异步I/O模型如下图所示：应用程序进程通过`aio_read`告知内核启动某个操作，并且在整个操作完成之后再通知应用程序进程，包括把数据从内核空间copy到用户空间。

![AsyncIO](https://user-images.githubusercontent.com/16413289/57979574-50062e00-7a52-11e9-8d58-758167d330df.png)

#### 特点

1. 没有任何阻塞，充分利用系统内核将I/O操作与计算逻辑并行
2. 缺点是变成复杂，操作系统支持不好。目前只有windows下的iocp实现了真正的AIO，linux下目前不够完善，所以一般linux下采用多路复用模型比较多。

### I/O模型比较

![IOModels](https://user-images.githubusercontent.com/16413289/57979682-e4bd5b80-7a53-11e9-8082-3fd1d000e8fd.png)

