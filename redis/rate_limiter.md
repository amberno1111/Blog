# RateLimiter

在高并发的时候，我们大致会用三种办法来保障系统的高可用：
- 缓存：目的是提升系统的访问速度、增大系统吞吐量
- 限流：通过对并发的请求进行限速，或者对在一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队等待或者降级等处理
- 降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开

# 使用Redis实现一个简单的RateLimiter

某些场景下，我们需要对单个用户的访问进行限制，限制用户每分钟只能访问某些资源N次，就可以使用`incr`和`expire`命令组合来实现。思路如下：
- 使用userId作为key，value初始值设置为0，`expire`设置过期时间为一分钟，存储到redis
- 当用户访问资源，先判断是否到限制次数了，如果没有到，就使用`incr`命令给value值加一；如果已经达到限制次数，就做其他处理
- 当key过期之后，可以重新设置key的值，用户就又能访问了

但这个限速器不是很准确，比如设置了用户每分钟只能访问10次，实际上，用户可以在某个时间段的一分钟内访问19次，来看下这个场景：用户在18:00:00的时候访问了一次，然后到18:00:51的时候开始每秒访问一次，到18:01:00总共可以访问9次，但是这个时候key过期了被充值，然后一直到18:01:10用户又能访问10次，总共在这个很短的时间内，用户访问了多达19次。
所以说这个限速器不是很准确，但是基本上还是可以满足一般的需要了。


## 常见的限流算法

说到RateLimter，就不得不提常见的两种限流算法：漏桶算法以及令牌桶算法。

# 漏桶算法

漏桶算法就是预先设置一个请求数的上限，小于这个上限的时候会接受请求，大于这个上限就直接拒绝，只有等到系统处理掉一些桶里的请求，桶里有新的坑位了，才会接受新的请求。

漏桶算法可以解决上面那个Redis做的简单RateLimiter的缺点，漏桶算法可以很好的控制用户的请求数，保证流量是均匀的，不会有突刺。

漏桶算法的实现还是简单的，可以用FIFO队列来做。

# 令牌桶算法

令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝用户请求。

这种算法生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的操作。



