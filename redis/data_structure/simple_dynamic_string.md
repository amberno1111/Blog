# Simple Dynamic String

Redis是使用C语言实现的，所以它底层的数据结构也是用C语言实现的。C语言自带字符串数据结构，但是Redis并没有直接使用C语言的字符串，而是自己构建了一种名为**简单动态字符串(Simple Dynamic String, SDS)**的抽象类型，并将SDS作为Redis默认的字符串表示。

为什么Redis要自己实现字符串呢？当然是因为C语言的字符串无法满足Redis的使用场景，Redis作为数据库，会有非常多的字符串修改以及查询操作，而C语言的字符串在这两个方面的性能都挺一般。

## SDS的定义

```c
struct sdshdr {
    // 记录 buf 数组中已使用的字节的数量
    int len;
    // 记录 buf 数组中未使用的字节的数量
    int free;
    // 字节数组, 用于保存字符串
    char buf[];
}
```

这个数据结构保证了：
- 获取字符串长度的操作从O(n)降低到了O(1)，C语言里通过遍历来获取字符串长度，而SDS只需要读取字符串的len属性即可
- 杜绝缓冲区溢出

这个数据结构同时也为**空间预分配**、**惰性空间释放**、**二进制安全**带来了可能。


## 空间预分配

> 因为在C语言中，修改字符串的时候需要重新分配内存，内存分配是一个比较复杂的算法，需要涉及到系统调用，所以通常是一个比较耗时的操作。

在一般的场景下，修改字符串是不太会出现的，因此每次修改就执行一次内存分配的性能损耗是可以接受的。但是Redis作为数据库，字符串的修改是极其频繁的，所以Redis使用SDS实现了**字符串空间预分配功能来提高字符串修改操作的性能**，其实是个典型的以空间换时间的操作。

在SDS中，buf数组的长度不一定就是字符串长度加一，数组里可以包含未使用的字节，而这些字节由free属性记录。当对SDS进行扩展的时候，Redis不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间，类似于Java里HashMap的扩容操作，并不是需要多少就扩容多少，而是根据某个公式来扩容，扩容的空间往往大于当前所需要的空间大小。

SDS空间分配的规则如下：
- 如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间， 这时SDS的len属性的值将和free属性的值相同。
- 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

## 惰性空间释放

惰性空间释放用于优化SDS缩短操作，当SDS进行缩短操作时，Redis并不会使用内存重新分配算法来释放内存，而是修改字符串的len和free值，这些空闲的字节可以留待后面使用。


## 二进制安全

C语言的字符串中的字符是符合ASCII编码的，这种编码的特点是：**遇到空字符就认为是这个字符串的结尾**，这就限制了C语言的字符串只能用来保存文本数据，而不能用来保存像图片、视频、压缩文件这样的二进制数据。

但是使用了SDS就完全没有这个问题，因为SDS并不是靠空字符来判断字符串的结尾的。







