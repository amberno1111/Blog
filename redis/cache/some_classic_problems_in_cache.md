# 缓存中的一些经典问题

服务端的缓存应用有一些经典的问题，在设计或者使用缓存的时候，这些问题都是需要确认并且解决的，不然很容易造成影响范围巨大的故障，如下：
- 缓存穿透、缓存击穿、缓存雪崩、缓存失效机制
- 缓存并发更新
- 缓存与数据库数据一致性问题


## 缓存穿透、缓存击穿、缓存雪崩、缓存失效机制

**缓存穿透**是指某条数据在缓存和数据库中都没有，然后会导致这条数据的每一次请求都直接落到数据库，请求量大的情况下可能会造成数据库崩溃。一般来说我们可以使用**给不存在的key设置一个特定的value来避免缓存穿透**，**高阶一点的解决方案有[布隆过滤器](bloom_filter.md)**。

**缓存击穿**是指某条数据非常热点，访问非常频繁，在这个key失效的瞬间，会有大量的请求直接落到数据库，导致数据库崩溃。
根据不同的场景，**缓存击穿有以下几张解决方案：**
- 如果缓存数据不更新，那么可以选择合适的缓存失效机制来解决，比如把热点数据设置为永不过期
- 如果缓存数据更新不频繁，并且刷新缓存的耗时较短的情况下，可以采用基于Redis、Zookeeper实现分布式互斥锁，或者本地实现互斥锁用于保证只有少量的请求能请求到数据库并且重新构建缓存数据，其余的线程在所释放后才能访问到更新后的缓存数据
- 如果缓存数据更新频繁或者刷新缓存耗时较长，可以利用定时线程在缓存失效之前主动重新构建缓存然后更新，或者也可以延后缓存的过期时间，以保证所有的请求都能访问到缓存数据

**缓存雪崩**是指大面积的缓存数据在某个时间点一起失效，会有大量的请求落到数据库，导致数据库崩溃。一般来说我们可以使用**写入缓存数据时给失效时间加一个随机的值来保证不会出现大面积的缓存失效情况**，或者也可以**选择合适的缓存失效策略，比如LRU，某些情况下也能避免出现大面积缓存失效的情况**。
应对缓存雪崩的完整策略如下：
- 保证缓存集群的高可用，可以使用[Redis Sentinel](../sentinel.md)、[Redis Cluster](../cluster.md)
- 使用本地内存+redis多级缓存，开启限流&降级策略
- 开启Redis持久化，缓存挂了之后重启可以从磁盘快速恢复数据


## 缓存并发更新

分布式系统中，肯定会存在多个客户端写同一条缓存数据的情况，这时候可能会由于网络啊啥的原因，导致本来该先写的数据延后写了，就会出现数据版本错乱的问题；也会存在多个客户端先取一条缓存数据，然后做修改，修改完成之后再写回去，这中间可能会有各种原因导致写入的顺序和取数据的顺序不符的情况，也会导致数据出错。

使用Redis的话，因为Redis是单线程的，收到的请求会放到队列里，所以一定会执行先到的请求，这个特性可以避免一部分简单场景下的并发更新问题。

当然更安全的做法还是使用各种中间件做一个[分布式锁](../distributed_lock_with_redis.md)。


## 缓存与数据库数据一致性问题

只要使用了缓存，就会存在缓存与数据库双写而导致的数据不一致问题。一般这种数据不一致的问题，第一反应的解决方案就是**串行化所有的请求**，这个方法贼简单粗暴有效，就是缺陷也很大，**会极大的降低系统的吞吐量。**

**Cache Aside Pattern**是一个比较经典的缓存、数据库读写模式：
- 先读缓存，如果缓存有，直接返回；如果缓存没有，读数据库，更新缓存，再返回
- 更新数据时，先更新数据库，再直接删除缓存！注意，是直接删除缓存

> 为什么直接删除缓存，而不是更新缓存？

在一个稍微复杂点的场景里，缓存一般都不是直接从数据库中取出来的，而是经过复杂的计算得出来的结果，即**缓存更新的代价是比较高的**。而且很有可能出现的情况是，修改了多个数据库表中的数据，导致一些缓存被更新了多次，但是实际上这些缓存可能在这个期间仅仅只是被访问了一次，中间的这些缓存操作就基本上是无效的操作了。但是如果删除缓存的话，就肯定是只有在被访问的时候才会重新计算缓存，可以计算很多计算量。

> 如果删除缓存失败了怎么办？可以先删除缓存，再更新数据库么？

如果删除失败，比较推荐对缓存删除的动作进行重试。
如果先删除缓存，再更新数据，可能在高并发下会存在比较严重的问题，比如先删除了缓存，然后去更新数据库，但是在数据库还没更新成功的时候，其他请求发现缓存没数据，直接去数据库里取到了旧的数据，然后更新到了缓存里，这时候数据库更新操作成功了，但是缓存里的还是旧数据，就出现了数据不一致的问题。
在这种高并发的场景下，还是先更新数据库再删除缓存比较靠谱。

