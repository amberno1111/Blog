# Java Memory Model

Java Memory Model即Java内存模型(JMM)，根据[JSR-133: Java Memory Model and Thread Specification](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)中的描述，它是一个跟多线程相关的概念。主要描述了一组规范，这些规范定义了在多个线程读写共享变量的场景下，当一个线程对改变了共享变量的值，其他变量能够读取到这个改变的值。

## 一些基础概念

因为JMM和并发编程相关，因此在开始介绍JMM之前，先来看一些基础概念。

### 线程的通信与同步机制

在并发编程中，有两个关键的问题：
- 线程之间如何通信
- 线程之间如何同步

通信指的是线程之间以什么机制交换信息，一般来说有两种通信机制：
- 共享内存：Java采用的就是共享内存模型，在这种模型里，多线程之间共享程序的公共状态，通过读、写内存中中的公共状态进行隐式通信
- 消息传递：消息传递就是一个线程给另一个线程发消息了，是显式的通信

同步指的是程序中用于控制不同线程之间的操作发生相对顺序的机制。在共享内存机制里，同步是显式进行的，需要程序员显式的编写代码来指定某些代码块或者方法需要在线程之间互斥执行；在消息传递机制里，同步是隐式进行的，消息的发送必须在消息的接收之前，所以能够保证指令的互斥执行。

### 原子性、可见性、顺序性

- 原子性：是指在执行一个操作时不会被中断，这个操作要么执行完成，要么不执行
- 可见性：是指在多线程访问共享变量的场景下，一个线程修改了共享变量的值，另一个线程可以看到这个修改过后的值
- 顺序性：是指程序执行的顺序按照代码的先后顺序执行

### 数据依赖性

**如果两个操作访问一个变量，且这两个操作中的写操作大于等于一个，此时这两个操作之间就存在数据依赖性。**

数据依赖分为三种，这三种情况下如果代码的执行顺序被变换，那么程序的执行结果就会发生改变，也就是说后一个指令的执行依赖于前一个：
- 写后读：`a=1; b=a`
- 读后写：`a=b; b=1`
- 写后写：`a=1; a=2`

### happens-beore

Java用happens-before的概念来描述操作之间的内存可见性。即，在JMM中，如果一个操作的执行结果如果需要对另一个操作可见，那么这两个操作之间就必须要存在happens-before关系，这里的两个操作可以在多个线程之间，也可以在一个线程之内。

比较常见的happens-before规则如下：
- 程序的顺序规则：一个线程中的每个操作，happens-before与该线程中任意的后续操作，即程序执行的操作是有序的，按照代码书写的顺序
- 监视器锁规则：对于一个锁的解锁操作，happens-before与随后对这个锁的加锁操作
- `volatile`变量规则：对于任意一个`volatile`域的写，happens-before与对这个域的读
- 传递性：如果A happens-before B，B happens-before C，那么A happens-before C


## Java内存模型抽象结构

在Java中，线程之间的通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。
JMM定义了Java线程与主内存之间的抽象关系，可以抽象成下图这种简单的模型，其中：
线程本地内存(Local Memory)也是一个抽象概念，线程私有的局部变量、方法定义参数、异常处理器参数等数据都存在本地内存当中；另外本地内存还缓存了该线程读/写共享变量的副本。这个概念实际上涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

![JMM](https://user-images.githubusercontent.com/16413289/60381728-fc90f200-9a8b-11e9-8a4f-0a03e06ab4ff.jpg)


从上图来看，两个线程同时读写共享变量，并且在它们的本地内存中都有这个变量的副本。正常的运转流程是，线程A在本地内存中对共享变量进行写入操作，然后把共享变量的值刷新到主内存；然后线程B直接从主内存中读取共享变量的值再进行后续的操作。

这个过程实际上就相当于线程A直接向线程B发送消息，JMM通过控制主内存与每个线程本地内存之间的交互顺序，来给Java程序员提供内存可见性保证。

### JMM解决的问题

编译器和处理器为了优化性能，会对代码和指令进行重排序，而这个重排序在多线程环境下会带来共享变量可见性的问题。

代码和指令的重排序包括以下几种：
- 编译器优化的重排序，编译器会在不改变单线程程序语义的前提下，重新安排语句的执行顺序，比如`a=1;b=2`，编译器可能会把顺序改成`b=2;a=1`。
- 处理器重排序，又分为以下两种：
    - CPU ILP，现代CPU使用了指令级并行技术(ILP)来提高处理器的性能，如果不存在数据依赖性，处理器会改变程序语句对应指令的执行顺序。
    - 内存系统的重排序，由于现代CPU使用了缓存和读/写缓冲区，这会使得加载和存储操作看上去是乱序执行。

在多线程环境下，这几种重排序都会带来可见性的问题(具体看后面的章节)，JMM会通过禁止特定类型的编译器重排序和处理器重排序来实现内存可见性保证:
- 对于编译器重排序，JMM会通过happens-before规则禁止特定类型的编译器重排序。
- 对于处理器重排序，JMM处理器会要求Java编译器生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型处理器重排序。

#### 编译器代码顺序&处理器指令执行顺序优化的重排序

处理器指令重排序和编译器优化重排序类似，都是直接改变指令的顺序，所以这里就放到一起介绍了。

我们来看一段代码：
```java
int a = 1;  // A
int b = 2;  // B
int c = a + b;  // C
```
根据Java的happens-before规则，我们可以确定 A happens-before B，B happens-before C。但实际上我们知道A和B是可以乱序执行的，因为它们之间实际上没有数据依赖。
某些编译器会把这两个操作的顺序打乱，而JMM允许这种合法的重排序，但是不允许有数据依赖的重排序(比如把C放到B、A之前执行)。

单线程环境下，上面的这种重排序不会改变程序的语义，但是在多线程环境下，这种重排序可能会出现问题，来看一个例子：
```java
public class ReorderDemo {
    int a = 0;
    boolean flag = false;
    public void write() {
        a = 1; // A
        flag = true; // B
    }
    public void read() {
        if (flag) { // C
            int b = a; // D
        }
    }
}
```

假设有两个线程，线程1和线程2，线程1先执行`write`方法，然后线程2执行`read`方法。这时候，线程2在执行D的时候，实际上A有可能都没有执行，因为编译器or处理器会对指令进行重排序。由于操作A和B没有数据依赖关系，C和D也没有依赖关系，它们都可以被重排序。

我们先来看如果A和B重排序之后的运行流程，线程1先执行B，然后线程2执行C，再执行D，这时候b=a=0，然后线程2执行A，完全得到了一个错误的结果。

如果C和D进行重排序，对即使代码中存在这种控制依赖性时，也会进行重排序。CPU会首先把`a`的结果保留到**重排序缓冲**中，然后当`flag`变为`true`时，再把这个`a`的结果写入到`b`，这时候得到的结果也可能时错误的。


**重排序在多线程的场景下完全破坏了程序的语义！！！**

这种情况下就只能通过加锁来解决了，显式的告诉编译器和处理器不要对这些代码进行重排序，锁可以加在`write`和`read`这两个方法上。

#### 处理器重排序

实际上，称为"内存系统的重排序"有些不妥，因为内存没有为了做优化而故意对指令做重排序。这里的指令乱序效果实际上是因为CPU引入了独立的缓存和写缓冲区(即每个CPU有自己的高速缓存和写缓冲区，这部分数据仅对当前CPU可见)而导致的。有了独立的缓存和写缓冲区之后，CPU都是把该了值的变量写到写缓冲区，然后再刷新到内存。

来看一个例子，假设我们现在有两个CPU，然后有两个在内存中的变量，初始状态为`a=b=0`，并发执行两段代码：
- CPU_A执行代码`a=1;x=b`
- CPU_B执行代码`b=2;y=a`

执行完毕之后的结果可能是`x=y=0`。执行流程是这样的：
- CPU_A和CPU_B分别把`a=b=0`读到自己的缓存
- CPU_A执行计算，计算完了之后`x=b(CPU_A的缓存区中的b)=0`；CPU_B同时执行计算，计算完了之后`y=a(CPU_B的缓存区中的a)=0`
- 最后两个CPU把结果刷新到内存，就得到了`x=y=0`的结果

JMM通过规定Java编译器在编译时插入特定的**内存屏障指令**来解决这个问题，内存屏障指令可以告诉CPU某些指令之间有数据依赖关系，必须根据数据依赖关系执行，而不是随意的重排序。

### 顺序一致性

**顺序一致性是指程序重排序之后的最终执行结果与按照程序的顺序锁执行的结果应该一致**。从上面的分析来看，在多线程场景下，处理器和编译器的重排序直接改变了程序的顺序一致性从而导致程序语义出现了改变。

我们一般使用**顺序一致性模型**作为参考模型，它有两大特性：
- 一个线程中所有的操作都必须按照这个程序的顺序执行。
- (不管程序是否同步)所有的线程都只能看到一个单一的操作执行顺序。在顺序一致性模型当中，每个操作都必须原子执行且立刻对所有的线程可见。





