# synchronized

在Java中，`synchronized`可以用来修饰类、方法以及代码块，其中方法可以是普通同步方法，也可以是静态同步方法。使用了`synchronized`之后的锁可以表现为三种形式：
- 对于普通同步方法，锁的是当前的实例对象
- 对于静态同步方法和类，锁的是当前类的class对象
- 对于同步方法块，锁的是`synchronized`括号里配置的对象

当一个线程试图访问同步代码块时，必须先获取锁才能开始操作，在退出或者抛出异常时又必须释放锁。
JVM是基于进入和退出`Monitor`对象来实现方法同步和代码块同步的，这两种实现的指令不太一样。代码块同步是通过`monitorenter`和`monitorexit`指令来实现的，方法同步是由方法调用指令读取运行时常量池中方法表结构的`ACC_SYNCHRONIZED`标志来隐式实现的。

在编译的时候，`monitorenter`和`monitorexit`会被插入到代码块的首尾，JVM会保证`monitorenter`和`monitorexit`的一一对应。任何一堆`monitorenter`和`monitorexit`指令都会和一个`monitor`对象绑定，持有`monitor`对象就相当于持有锁。当线程执行到同步代码块时，遇到`monitorenter`指令，就会尝试去获取对应的`monitor`对象。

## Java对象头

对于Java来说，一切皆对象。锁的信息自然也是存在对象数据里，实际上是存在对象头里。
如果对象是数组类型，那么JVM就会用3个字宽存储对象头；如果是普通对象，则使用2个字宽存储对象头。在32位JVM中，一个字宽表示32bit；在64位JVM中，一个字宽表示64bit。

Java对象头里存储的数据主要分为三部分：
- Mark Word：默认存储对象的HashCode、分代年龄、锁标记位
- Class Metadata Address：存储对象数据类型的指针
- Array Length：数组的长度(如果当前对象是数组)

## 锁

JDK6中为了减轻获得锁和释放锁带来的性能损耗，引入了**偏向锁**和**轻量级锁**的概念，锁一共被分为4种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以根据这个优先级顺序不断的升级，但是不能降级。

### 偏向锁

在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，JDK6引入了**偏向锁**。

偏向锁的具体做法是：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，以后该线程进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要简单的判断一下对象头的Mark Word里是否存储着指向当前线程的偏向锁即可。如果是，则表示线程已经获取了锁；如果不是，则需要再判断一下Mark Word中偏向锁的标识是否设置成了1(表示当前是偏向锁)；如果已经设置为1，则尝试使用CAS把对象头的偏向锁指向当前线程；如果没有设置为1，则直接使用CAS竞争锁。

#### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，当其他的线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销流程比较麻烦，开销也较大：
- 首先需要等到一个全局安全点(这个时间点没有正在执行的字节码)，然后暂停拥有偏向锁的线程
- 遍历线程栈，如果存在锁记录，则需要修复锁记录和对象的Mark Word，使其变成无锁状态
- 唤醒当前线程，将当前的锁升级成轻量级锁

#### 关闭偏向锁

从偏向锁的撤销来看，当存在竞争的时候，偏向锁就会升级到轻量级锁。也就是说，再线程竞争的情况下，直接使用轻量级锁可能会更好，JVM提供关闭偏向锁的参数`-XX:UseBiasedLocking`，设置为false的情况下就会一开始就使用轻量级锁。


### 轻量级锁

线程再执行同步代码块时，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，这个操作称之为Displaced Mark Word。然后线程会尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，则当前线程获得锁；如果失败则表示其他线程也在竞争锁，当前线程尝试通过自旋来获取锁。

轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回对象头，如果成功则表示没有竞争；如果失败，则表示当前锁存在竞争，锁就会升级成重量级锁。

**自旋**：指当由一个线程来竞争锁时，这个线程会在原地循环等待，而不是被阻塞，直到当前拥有锁的线程释放锁之后，这个线程就可以马上获取锁。自旋的时候是会消耗CPU的，相当于在执行一个没什么用的for循环。

所以轻量级锁比较适合的场景是同步代码块执行的非常快，自旋的线程在原地等待很短的时间就能够获取锁了。但是一旦同步代码块执行的比较慢，就会有很多自旋的线程一直在消耗CPU，这对性能的影响非常大，所以一般会给空线程设置一个循环的次数，超过这个次数了之后，我们就认为这个场景已经不适合使用轻量级锁了，就可以升级成重量级锁。

### 重量级锁

重量级锁是以来对象内部的`monitor`锁来实现的，因为`monitor`又依赖于操作系统的`MutexLock`(互斥锁)来实现的，所以重量级锁也被称为互斥锁。

为什么说重量级锁开销大呢？是因为当系统检查到锁是重量级锁之后，会把等待想要获取锁的线程挂起，被挂起的线程不会消耗CPU，然后等到锁释放了再唤醒这个线程进行锁的竞争。这个线程被挂起又被唤醒的过程其实是线程的上下文切换，而上下文切换是非常消耗性能的，因此说重量级锁的消耗非常大。

