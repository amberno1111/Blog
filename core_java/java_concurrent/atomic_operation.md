# 原子操作的实现原理

**原子操作指的是不可被拆分的一个或者一系列操作。** 在处理器和Java语言层面都有**原子操作**的概念，并且它们都使用了一些比较复杂的机制来实现**原子操作**。

## CPU是如何实现原子操作的

先来了解一些CPU工作机制相关的概念：

* 缓存行\(cache line\)：这个之前介绍过，是CPU读or写缓存的最小操作单位
* CPU流水线\(CPU pipline\)：CPU为了提高运行速度，会将一整个指令拆分为很多步，然后让不同指令的各步操作重叠，从而实现几条指令的并行处理
* 内存顺序冲突：多个CPU同时修改一个缓存行的不同部分，会引起其中一个CPU的操作无效，当出现内存顺序冲突时，CPU必须清空流水线
* 比较并交换\(Compare and Swap\)：处理器提供了CMPXCHG指令，这个指令的输入时一个旧的值，一个新的值，在操作之前会对比旧值有没有发生变化，如果发生了变化则不继续进行交换操作，如果没有发生变化，则进行交换操作\(用新值去更新变量的值\)

现在的处理器实现原子操作有两种机制，这两个一起使用才能保证处理器的原子性操作：一是对总线加锁、二是对缓存加锁。

首先处理器能够保证基本的内存操作的原子性，处理器从系统内存中读取或者写入一个字节是原子操作，即当一个处理器读写一个字节的时候，其他处理器就不能访问这个字节的内存地址。

但是，如果遇到复杂的内存操作，处理器是不能保证操作的原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。这时候就需要其他的机制来实现原子操作了。

### 对总线加锁实现原子操作

在多个处理器处理共享变量的场景下，每个处理器都会从各自的缓存中读取共享变量的值然后进行操作，如果要保证原子性，就需要保证**在一个处理器对共享变量进行操作时，另一个处理器不能操作缓存了该共享变量地内存地址的缓存**。

对总线加锁就能解决这个问题，处理器如果想访问内存，就必须经过总线。对总线加锁能够保证当一个处理器在总线上输出信号时，其他处理器的请求都会被阻塞，这时候这个处理器就能独占共享内存。

但是总线锁的代价非常大：我们其实只需要保证对某个内存地址的操作是原子性的就好了，而给总线加锁会直接锁住其他CPU访问整个内存中的数据，导致其他CPU不能访问跟这个原子操作无关的内存地址，这个性能损耗是非常大的。

### 对缓存加锁实现原子操作

在频繁使用的内存已经被缓存在处理器高速缓存中的场景下，对缓存加锁的性能损耗就比对总线加锁要低的多，**缓存加锁实际上就是**[**CPU的缓存一致性机制**](mesi.md)。当共享变量被缓存，处理器写这个共享变量时就直接修改缓存，触发缓存一致性协议，更新其他处理的缓存或者让其他处理器直接从内存中重新读取这个共享变量的值。

### 某些无法对缓存加锁的场景

有两种情况下，无法对缓存加锁：

* 一是当操作的数据无法被缓存在处理器的高速缓存中，或者操作的数据跨多个缓存行时，处理器会使用总线锁定
* 二是有些处理器不支持缓存锁定

## Java是如何实现原子操作的

Java里通过锁和CAS算法一起实现了原子操作。

### 使用循环CAS实现加锁操作

JVM里的CAS实际上就是利用了处理器提供的CMPXCHG指令来实现的。Java里使用的比较多的是**自旋CAS**，基本思路就是循环进行CAS操作直到成功为止。

### CAS实现原子操作的三大问题

CAS操作是无锁的，虽然比较高效的实现了原子操作，但还是存在一些问题。

#### ABA问题

因为CAS在操作时会检查旧值有没有发生变化，所以存在这种情况：一个变量的值是A，然后被线程1改成B，然后又被线程1改成A，然后线程2使用CAS改这个变量发现还是A，它会认为值没有发生变化。但实际上这个值是发生了变化的。

ABA的解决思路就是加上版本号，每次更新都加一个版本。

#### 循环时间长开销大

自旋CAS如果长时间不成功，那么这个线程也依旧会长时间占用CPU，然后这个自旋操作其实基本上是无意义的操作，这就导致CPU的开销会很大。

#### 只能保证一个共享变量的原子操作

对于一个共享变量执行操作时，我们可以使用循环CAS的操作来保证原子操作，但是对多个共享变量操作时，就无法使用循环CAS，这时候只能使用锁。

