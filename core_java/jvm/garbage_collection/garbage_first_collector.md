# G1垃圾收集器

G1(Grabage First)收集器也是以关注低延迟为目标、服务端应用的垃圾收集器。
对比之前提到的一些Serial、ParNew、CMS等收集器，G1显的更加独特一些，有如下特点：
- G1的设计目标是**收集尽可能多的垃圾(Garbage First)**，因此G1不会等内存耗尽(Serial,ParNew等)或者内存即将耗尽(CMS)的时候才开始垃圾收集，而是在内部使用了启发式算法，找出具有高收集收益的分区进行收集。
- 采用了内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另外一个空闲分区中。相当于每次操作都是以一个相等大小的内存区块为单位，所以G1天然就是一种压缩算法，基本上不会存在内存碎片的问题。
- G1保留了分代的概念，但是G1并不需要其他垃圾收集器配合就能管理整个堆空间。而且G1的分代概念只是逻辑上的，不像之前的垃圾收集器新生代和老年代内存块物理隔离。
- G1能建立可预测的停顿模型，它能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。
- G1的收集也是STW的，但是年轻代和老年代的收集界限比较模糊，采用了mixed收集，即每次收集可能只收集老年代也可能只收集年轻代或者两者都同时回收。


## G1的一些重要概念

- Region、Card
- Generation
- SATB
- RSet
- Pause Prediction Model

### Region

传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代(JDK8去除了永久代，引入了Metaspace)，这种划分的特点是，这些分区的内存块是物理隔离的，它们之间有明显的界限。
**而G1采用了分区(Region)的概念，它的各代存储地址是不连续的。每一代都是用了n各不连续的、大小相同的Region，每个Region占有一块连续的虚拟内存地址。**

#### Card

每个分区内部又被划分为若干个大小为512Byte的卡片(Card)，标识堆内存最小可用粒度。所有的分区的卡片都会被记录在全局卡片表中，分配的对象会占用物理上连续的若干个卡片，当查找对象分区的引用时，便可通过扫描记录卡片来查找该引用对象。每次内存回收都会对指定分区的卡片进行处理。

#### Heap

G1可以通过`-Xmx/-Xms`指定堆空间的大小，但是堆空间不是一次性分配完毕的，而是可以动态调整的。当发生年轻代收集和混合收集时，通过计算GC与应用的耗费时间比，自动调整对空间的大小。如果GC频率太高，可以通过增加堆尺寸来减少GC频率，相应的GC占用的时间也随之降低。当空间不足时，G1会首先尝试增加堆空间，如果扩容失败才会发起Full GC。Full GC结束后也会重新调整堆空间。

### Generation







