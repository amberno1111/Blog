# G1垃圾收集器

G1(Grabage First)收集器也是以关注低延迟为目标、服务端应用的垃圾收集器。
对比之前提到的一些Serial、ParNew、CMS等收集器，G1显的更加独特一些，有如下特点：
- G1的设计目标是**收集尽可能多的垃圾(Garbage First)**，因此G1不会等内存耗尽(Serial,ParNew等)或者内存即将耗尽(CMS)的时候才开始垃圾收集，而是在内部使用了启发式算法，找出具有高收集收益的分区进行收集。
- 采用了内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另外一个空闲分区中。相当于每次操作都是以一个相等大小的内存区块为单位，所以G1天然就是一种压缩算法，基本上不会存在内存碎片的问题。
- G1保留了分代的概念，但是G1并不需要其他垃圾收集器配合就能管理整个堆空间。而且G1的分代概念只是逻辑上的，不像之前的垃圾收集器新生代和老年代内存块物理隔离。
- G1能建立可预测的停顿模型，它能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。
- G1的收集也是STW的，但是年轻代和老年代的收集界限比较模糊，采用了mixed收集，即每次收集可能只收集老年代也可能只收集年轻代或者两者都同时回收。


## G1的一些重要概念

- Region、Card
- Generation
- TLAB
- SATB
- Collection Sets
- RSet
- Pause Prediction Model

### Region

传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代(JDK8去除了永久代，引入了Metaspace)，这种划分的特点是，这些分区的内存块是物理隔离的，它们之间有明显的界限。
**而G1采用了分区(Region)的概念，它的各代存储地址是不连续的。每一代都是用了n各不连续的、大小相同的Region，每个Region占有一块连续的虚拟内存地址。**

#### Card Table

每个分区内部又被划分为若干个大小为512Byte的卡片(Card)，标识堆内存最小可用粒度。所有的分区的卡片都会被记录在全局卡片表(Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对象分区的引用时，便可通过扫描记录卡片来查找该引用对象。每次内存回收都会对指定分区的卡片进行处理。

#### Heap

G1可以通过`-Xmx/-Xms`指定堆空间的大小，但是堆空间不是一次性分配完毕的，而是可以动态调整的。当发生年轻代收集和混合收集时，通过计算GC与应用的耗费时间比，自动调整对空间的大小。如果GC频率太高，可以通过增加堆尺寸来减少GC频率，相应的GC占用的时间也随之降低。当空间不足时，G1会首先尝试增加堆空间，如果扩容失败才会发起Full GC。Full GC结束后也会重新调整堆空间。

### Generation

分代垃圾收集可以将对象分类，无需扫描整个堆，避免长对象的拷贝，对不同年代对象的独立收集也可以降低响应时间。
传统的垃圾收集器里不同年代的对象分区是物理上隔离的，而在G1里，因为采用了Region的概念，所以年轻代和老年代不再物理隔离，只是在逻辑上把内存划分为了年轻代和老年代，年轻代同样又划分为Eden区和Survivor区。
但是年轻代的空间大小不是固定不变的，当年轻代分区占满时，G1会对年轻代分区进行扩容(在不设置固定年轻代大小参数的前提下才会扩容)。

G1提供设置固定的年轻代大小的参数(`-XX:NewRatio`、`-Xmn`)，但是一般不推荐使用，因为设置了固定年轻代空间大小会使得暂停目标参数失去意义，因为G1会通过调整年轻代大小来实现用户设置的暂停目标。
一般来说，使用G1时推荐`-XX:G1NewSizePercent`(初始空间，默认是整堆的5%)、`-XX:G1MaxNewSizePercent`(最大空间，默认整堆的60%)来控制年轻代的大小，G1会在这个范围内动态的调整年轻代的大小(通过用户设置的`-XX:MaxGCPauseMillis`(默认200ms)、需要扩容的大小以及RSet里的数据计算得到年轻代的大小)。

### TLAB

G1默认开启了TLAB优化，每个线程都会被分配某个分区用于线程本地的内存分配，从而减少线程同步的时间，提升内存分配的效率。

应用线程所分配的对象大部分会落入Eden区(巨型对象或者分配失败除外)，因此TLAB的分区属于Eden空间。每次垃圾收集时，每个GC线程同样可以独占一个本地换从区(GCLAB)用来转移对象，每次回收会将对象复制到Survivor空间或者老年代空间；对于从Eden/Survivor空间晋升到Survivor/老年代空间的对象，同样会有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。

#### 巨型对象

在G1里，任何超过一个Region一半大小的对象都称为巨型对象(Humongous Object)。但线程为巨型对象分配空间时，不会简单的在TLAB上进行分配，因为巨型对象的移动成本很高，而且有可能一个Region不能容纳一个巨型对象。
因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。这些巨型分区由一些连续的分区组成，因为巨型对象会独占一个或多个连续分区。这些巨型分区的第一个分区被标记为StartsHumongous，相邻连续分区被标记为ContinuesHumongous。

这些巨型对象可以在年轻代的收集周期中就被回收！

由于巨型对象无法享受本地线程缓冲带来的优化，并且确定一片连续的内存空间需要扫描整个堆，所以确定巨型对象开始位置的成本很高。

### Remember Set

在其他垃圾收集器中，GC通过整堆扫描来确定对象是否处于可达路径当中，然而G1为了避免STW式的整堆扫描，在每个Region里都保存里一个Remember Set，这个RSet里保存里一个反向指针，记录了**其他Region中的对象对本Region内的对象的引用**。
当进行Minor GC时，只要扫描Rset中其他old区对象对于本young区的引用，不需要扫描所有的old区。
当进行Mixed GC时，扫描old区的RSet中，其他old区对本old分区的引用，一样不需要扫描所有的old区。

关于RSet里所保存的数据，RSet并非保存了对应的Region内的所有引用，原因如下：
- G1每次都会对年轻代进行收集，也就是说每次GC都会扫描所有的young区对象，所以如果这个Region内的young区对象被其他Region的对象引用的话，是没有必要记录的。
- 如果一个Region确定需要在GC的时候进行扫描，那么不需要RSet也可以得到引用关系。所以如果是引用了本Region内的对象，那么这个引用关系也没必要记录在RSet中。

所以实际上之后old引用young，old引用old的情况下，才会把这个引用关系保存在RSet当中。


#### RSet的维护





### Collection Set

Collection Set(CSet)是GC中待回收的Region的集合，也就是每次GC暂停时所需要回收的一些目标Region。
CSet中可能存放着各个分代的Region，所有的Region都会被释放，其中存活的对象会在GC中被移动(复制)到空闲分区中。因此无论是年轻代还是老年代，其收集算法都是一致的，就是复制-清除算法。

年轻代CSet只容纳年轻代Region，而混合收集的时候，会通过启发式算法，在老年代候选的Region中，筛选出回收收益最高的分区，并添加到CSet中。
候选老年代Region的CSet准入条件，可以通过`-XX:G1MixedGCLiveThresholdPercent`(默认85%)来控制，这个参数设置可以拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代Region数量可以通过`-XX:G1OldCSetRegionThresholdPercent`(默认10%)来设置，这个比例指的是CSet跟Heap的总大小的比值。

由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。

#### CSet of Young Collection

当Eden区已满时，就会触发一次STW式的Minor GC，每次Minor GC都会回收所有的Eden以及Survivor区。在Minor GC中，Eden区存活的对象被拷贝到Survivor分区，原有的Survivor分区的对象，则会开始晋升流程，可能会被移动到到PLAB、新的Survivor分区或者老年代分区等。而原来的年轻代分区则会被整体回收。

Minor GC的时候还会维护对象的年龄、判断对象晋升是到Survivor区还是老年代区。JVM此时会收集晋升对象的大小总和、对象的年龄信息维护在年龄表中，然后根据年龄表、Survivor区的大小，Survivor区被占用的容量比例(`-XX:TargetSurvivorRatio`(默认50%))、`-XX:MaxTenuringThreshold`(默认15)这些参数计算出一个年龄的阈值，只要是超过这个年龄阈值的对象，都会被晋升到老年代。


#### CSet of Mixed Collection

当老年代在堆中占用的空间大小比例超过一定的阈值时(`-XX:InitiatingHeapOccupancyPercent`(默认45%))时，G1就会启动一次Mixed GC。为了满足用户所设置的暂停目标，G1有可能不会一次就把所有的候选分区收集掉，因此G1会产生连续多次的Mixed GC与引用线程交替执行，每次STW的Mixed GC都和Minor GC的过程类似。

为了确定哪一些老年代Region放到CSet中，G1会通过`-XX:G1MixedGCCountaTarget`(默认8)确定每次加到CSet中的最小老年代Region数量。通过`-XX:G1HeapWastePercent`(默认5%)这个参数确定当需要收集的垃圾小于这个参数时，不再启动新的Mixed GC。
