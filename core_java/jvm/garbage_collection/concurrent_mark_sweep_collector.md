# CMS垃圾收集器

CMS垃圾收集器，全称Concurrent Mark Sweep Collector，它比较适合具有以下特征的应用场景：

* 重视服务响应速度甚于吞吐量，希望系统停顿时间最短
* 有足够的机器的资源，能够接受垃圾回收线程与应用线程共享处理器资源
* 应用中存在比较多的长生命周期的对象

CMS是基于标记-整理算法的老年代垃圾收集器，它一般和ParNew收集器一起配合使用。设置虚拟机参数`-XX:+UseConcMarkSweepGC`就可以使用CMS垃圾收集器来进行垃圾收集工作，这个时候会默认开启参数`-XX:+UseParNewGC`，即默认使用ParNew对新生代进行垃圾收集工作。

## CMS工作过程

CMS的工作过程如下：

* 初始标记(initial mark)
* 并发标记(concurrent mark)
* 并发预清理(cuncurrent pre-clean)
* 重新标记(remark)
* 并发清除(concurrent sweep)
* 并发重置(concurrent reset)

在CMS的整个工作过程中，只有初始标记和重新标记这两个过程是需要暂停用户线程的，其他三个过程都是可以和用户线程并行运行的。由于垃圾回收的大部分耗时都是在并发标记与并发清除阶段，所以CMS基本上已经把停顿时间降低到最小了，但实际上还是无法完全消除用户线程的停顿时间。

### 初始标记

初始标记过程很简单，速度非常快，耗时也很短。所做的工作就是进行可达性分析，先暂停所有的用户线程，然后标记一下GC Roots能直接关联到的对象(不包括间接关联的对象)(标记过程中会维护一个标记栈，把符合条件的对象存储在标记栈中)。标记完成之后恢复用户线程。

### 并发标记

这个阶段用户线程和垃圾收集线程可以一起工作，虚拟机会开启多个垃圾收集线程(默认线程数=((CPU数量)+3)/4，或者可以用户自己设置)进行可达性分析，标记那些GC Roots最终可达的对象。具体做法就是pop标记栈中的对象，然后标记这些对象所直接引用的子对象，把子对象push入标记栈，再继续pop标记栈中的对象，递归的进行如上的操作，直到整个标记栈被清空。

#### 写入屏障

在并发标记阶段，由于用户线程和垃圾收集线程一起工作，所以肯定会出现并发中常见的同步问题。比如这个场景：A引用B，B引用C，然后当垃圾收集线程把标记完A的所有自对象之后，把A从栈中弹出，垃圾收集线程之后就不会再去遍历A的子对象了。但是这时候如果用户线程的执行逻辑是从B中去掉C的引用，建立A对C的引用。这时候，垃圾收集线程会认为C是不可达的对象(因为不会再去遍历A了)，所以C就会被漏标记。

为了解决这个问题，引入了写入屏障(Write Barrier)的概念：当改写一个引用的时候，插入一段额外的代码，这段代码保证了当改写引用的时候，会对新引用的对象做一次判断，如果这个对象已经被标记了就什么也不做，继续执行；如果这个对象没有被标记，就把这个对象标记后push到标记栈里。 对应到上面的场景就是：对C进行判断，发现C没有被标记，所以直接把C push到标记栈里，这样就不会漏标记C了。

### 并发预清理

这个阶段是并发执行的，可以通过参数`-XX:-CMSPrecleaningEnabled`关闭，默认是开启的。这个阶段所做的工作，主要是为了减少后续的重新标记的开销,。

由于之前的并发标记步骤也是并发执行的，所以可能会产生一些新的老年代垃圾，或者老年代的对象被新生代重新引用，这些对象都是需要重新标记的，并发预清理主要标记以下这些对象：

* 新生代对象晋升到老年代
* 新生代新创建了对象引用了原先老年代未被标记的对象
* 直接在老年代分配的新对象
* 老年代对象的引用关系发生变化

对于场景2来说，垃圾收集器可能需要去扫描整个新生代的对象才能确定老年代中的某些对象是否可以回收。这就会出现一个问题，CMS对老年代进行回收相当于要同时扫描一边新生代和老年代，这个效率就会比较低。

**所以必须有一个能够快速识别新生代和老年代对象是否活着的机制！**

先说怎么处理新生代，HotSpot给出的答案是，直接进行一次 minor GC，因为一次 minor GC 之后，新生代剩下的对象基本上全是活的，然后再开始扫描新生代就会快很多。

另外，重新标记扫描新生代过程是多个垃圾收集线程并发的，为了提高效率，预清理阶段会将新生代分块。每个块中存放着多个对象，这样重新标记阶段就不需要从头开始识别每个对象的起始位置。把分块分配给多个线程，扫描效率就会很高。


关于怎么处理老年代，可以看后面的卡表。

### 重新标记

在并发标记期间，因为垃圾收集线程和用户线程一起工作，用户线程会不断的变更对象引用，此时GC Roots可能会发生变化，重新标记阶段就是为了同步更新这些对象间的引用关系变化，这个更新过程是增量的，所以速度会比并行标记阶段快很多。

重新标记的执行逻辑如下：重新从当前的GC Roots和指针更新的区域出发再进行一次标记。如果是已经标记过的对象，那么会直接跳过。所以重新标记只会遍历那些新增的没有标记过的活动对象和其间有发生引用变化的活动对象，如果引用更新频繁，重新标记有可能会遍历新生代中大部分的甚至全部对象，这时候可以发动一次Minor GC，以减少重新标记的工作量并减少用户线程的停顿时间。

### 并发清除

这个过程就是执行标记-清除算法的过程，一般来说耗时是比较长的，但是可以跟用户线程同时运行。GC线程会遍历整个老年代，遇到没有被标记的对象就清空掉相应的内存块，并把这部分内存块加入可分配列表；遇到被标记的对象，则重置其标记位用于下一次GC，不做其他额外的操作。

### 并发重置

这个阶段主要是一些善后操作，比如重新调整堆的大小，并为下一次GC做好数据结构支持，重置卡表(card table)的标位等等。

## 卡表(card table)

Minor GC中有一个经典的问题，基本上是所有的垃圾收集器都会遇到的：Minor GC时垃圾回收的目标是只回收新生代中的对象，但是新生代中的对象可能被老年代引用，这样的话进行Minor GC的时候就需要同时扫描新生代和老年代才能确定新生代的哪些对象是可以被回收的。然而扫描老年代是非常耗时的工作，所以CMS使用来一个空间换时间的思路，就是用卡表(card table)保存一些数据，以提高扫描老年代的效率。

具体原理如下：老年代内存被划分为一个个大小相等的卡片(HotSpot默认每个卡片是128个字节)，然后给每个卡片准备一个对应的标记位，这些卡片的集合就是卡表，card table的结构是一个连续的byte[]数组。当改写对象的引用是从老年代指向新生代时，在老年代对应的卡片标记位上设置标记位即可，被标记了之后的卡片称之为dirty card。这个标记的操作使用了write barrier实现。所以Minor GC时tracing GC Roots的操作就只需要遍历被标记了的卡片上的对象即可，极大的提升了性能。

## GC Log解析

在开始分析 GC Log 之前，有几个前置知识点需要了解：
- GC Log 基本上都是这种格式：回收前区域占用的大小->回收后区域占用的大小（区域设置的大小），占用的时间。
- 新生代的对象分配都在 Eden 区，只有应用程序创建对象这一个来源
- 老年代的对象有三个来源：
    - 一次晋升可能带来一大批对象在老年代的分配
    - 如果设置了-XX:PretenureSizeThreshold参数，则大于这个设置值的对象会直接在老年代分配
    - 如果空间分配担保通过，Minor GC 时 Survivor 无法容纳的对象也会直接进入老年代
- 即使设置了-XX:MaxTenuringThreshold参数，JVM也不一定会严格按照这个参数来进行晋升，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold规定的年龄就可以晋升

假设现在运行的应用设置了以下这些参数(这里的是`jinfo -flags pid`的结果)：
```
// non - default 的意思是，这部分参数被修改了，通过启动项或者其他的什么方式修改的，这些参数的值和 JVM 默认的参数值不一样了
// 这里只列出了跟 GC 相关的参数
Non-default VM flags: 
// 这两个参数指定了在老年代达空间使用率到 70% 的时候才会开始回收
-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly
// 堆的大小为 4294967296B = 4G，初始堆大小和最大堆大小都是 4G
-XX:InitialHeapSize=4294967296 
-XX:MaxHeapSize=4294967296
// 直接内存大小 1073741824B = 1G 
-XX:MaxDirectMemorySize=1073741824
// 年轻代的大小是 2G
-XX:NewSize=2147483648 
XX:MaxNewSize=2147483648
// 老年代的大小 2G
-XX:OldSize=2147483648 
// 对象年龄超过 15 就会晋升到老年代
-XX:MaxTenuringThreshold=15 
// 老年代使用 CMS 收集器，新生代使用 ParNew 收集器
-XX:+UseConcMarkSweepGC 
-XX:+UseParNewGC
// 表示新生代和老年代的比例是 1:1
-XX:NewRatio=1 
```

所以根据这些参数可以得到的信息是：
- 堆大小：4294967296B = 4G
- 老年代大小：2147483648 = 2G
- 新生代大小：2147483648 = 2G
- Survivor 区大小：1 / 10 * 新生代大小 = 214748364.8 B = 204.8 M
- Eden 区大小：8 / 10 * 新生代大小 = 1.6G

然后我们来看在这些参数设置下，出现的一些 GC Logs。

### ParNew GC Log

因为 CMS 一般都是和 ParNew 配合使用，所以先来看一下 ParNew 的 GC Log：

```
2019-11-20T20:14:56.719+0800: 609329.751: [GC (Allocation Failure) 2019-11-20T20:14:56.719+0800: 609329.751: [ParNew
Desired survivor size 107347968 bytes, new threshold 1 (max 15)
- age   1:  179519960 bytes,  179519960 total
- age   2:   35175912 bytes,  214695872 total
: 1841001K->209664K(1887488K), 1.6269643 secs] 2522354K->1508479K(3984640K), 1.6271583 secs] [Times: user=4.97 sys=0.04, real=1.63 secs] 
```

这一段是 Minor GC 的日志，可以看到 `1841001K(新生代回收前大小)->209664K(新生代回收后大小)(1887488K(新生代总大小)), 1.6269643 secs(这次回收的耗时)`，新生代在这一次回收过程中，回收了(1841001 - 209664 ) / 1024 /1024 = 1.55G 的数据。

`2522354K(回收前堆的大小)->1508479K(回收后堆的大小)(3984640K(堆的总大小))`，这一次回收过程中，堆中被回收的数据大小为(2522354 - 1508479) / 1024 / 1024 = 0.99G。

所以这中间，肯定有部分数据从新生代晋升到了老年代，这部分数据大小为 1.55 - 0.99 = 0.56 G。

但是我们看到，在开始这次 Minor GC 之前，age = 1 的新生代对象大小为 179519960 / 1024 /1024 = 171 M > Survivor 区大小的一半，所以大于等于 age = 1 的对象全部进入老年代，所以老年代的大小增加了不少。


### CMS GC Log

#### promotion failed 引发的 CMS GC

```
2019-11-20T20:15:00.394+0800: 609333.425: [GC (Allocation Failure) 2019-11-20T20:15:00.394+0800: 609333.425: [ParNew (promotion failed): 1887488K->1887488K(1887488K), 1.0994435 secs]2019-11-20T20:15:01.493+0800: 609334.525: [CMS: 1360981K->800492K(2097152K), 2.8178666 secs] 3186303K->800492K(3984640K), [Metaspace: 118407K->118407K(1159168K)], 3.9175056 secs] [Times: user=4.74 sys=0.29, real=3.92 secs] 
```

只是一次担保失败引发的的 CMS GC，在进行 Minor GC 之前，会首先检查老年代最大可用的连续空间是否大于新生代的总对象大小，如果是，则这次 Minor GC 是安全的，否则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的对象的平均大小，如果小于，则发动一次 CMS GC，同时会对老年代也进行回收。

`[ParNew (promotion failed): 1887488K->1887488K(1887488K), 1.0994435 secs]` 从这里来看，新生代已经满了，所以准备发起一次 Minor GC，但是检查了老年代最大可用的连续空间大小，发现不满足需求。

`[CMS: 1360981K(回收前老年代的大小)->800492K(回收后老年代的大小)(2097152K(老年代的总大小)), 2.8178666 secs(这次回收所花费的时间)] 3186303K(回收前堆的大小)->800492K(回收后堆的大小)(3984640K(堆的总大小)), [Metaspace: 118407K->118407K(1159168K)], 3.9175056 secs] [Times: user=4.74 sys=0.29, real=3.92 secs] `所以发动了一次 CMS GC。可以看到回收前老年代的剩余空间是(2097152 - 1360981) / 1024 = 719M，很明显历次晋升到老年代对象的平均大小不可能有700M这么大，所以这里肯定是因为内存碎片的问题引发的。


#### concurrent mode failure

```
2019-11-20T20:21:35.474+0800: 609728.505: [GC (Allocation Failure) 2019-11-20T20:21:35.474+0800: 609728.505: [ParNew: 1887488K->1887488K(1887488K), 0.0000226 secs]2019-11-20T20:21:35.474+0800: 
// 从这里可以看出，这时候正在进行 CMS 的清除算法，并且已经清除完毕
609728.506: [CMS2019-11-20T20:21:36.095+0800: 609729.127: [CMS-concurrent-sweep: 1.722/1.731 secs] [Times: user=3.13 sys=0.00, real=1.73 secs] 
// 然后紧接这来了一个 concurrent mode failure
 (concurrent mode failure): 1477784K->1271642K(2097152K), 4.1413569 secs] 3365272K->1271642K(3984640K), [Metaspace: 118409K->118409K(1159168K)], 4.1417989 secs] [Times: user=4.04 sys=0.02, real=4.14 secs] 
```

可以看到开始 concurrent mode failure 之前，老年代的大小还是有 1477784K = 1.4G，而之前已经进行过一次清除，说明上一次清除的效果很一般。另外在一次 concurrent mode failure 之后，老年代只减少了 (1477784-1271642) / 1024 = 201M，说明在这个阶段，老年代存在比较多or比较大的对象。



## CMS的缺点

CMS存在三个问题：
- 并发导致的资源占用率高
- 并发清理导致的浮动垃圾
- 标记-清除算法带来的内存碎片

### 并发导致的资源占用率高

CMS本身是多线程的，默认会开启(CPU + 3)/4个线程来进行垃圾回收。当CPU资源大于等于4的时候，基本上可以保证小于等于25%的CPU资源用于垃圾回收，这个比例还是挺合理的，用户线程不会因为与垃圾回收线程抢夺资源而变慢。但是，当CPU数量小于4的时候，比如2个CPU，这个比例就达到了50%，也就是说用户线程至少变慢了50%，这是很难接受的。

但是这个问题其实没太多的解决办法，只能加CPU，或者换其他的垃圾收集器。

### 并发清理导致的浮动垃圾

CMS垃圾回收线程和用户线程在某些阶段是并发执行的，这也就会导致垃圾回收的同时，用户线程还在创造垃圾，而这部分垃圾还没有被标记，称之为**浮动垃圾**，这部分垃圾是需要在下一次GC的过程中被回收的。

但是，这部分浮动垃圾依然占内存啊，如果CMS等到老年代满了才开始收集，那么这部分浮动垃圾就没有内存空间可以用了，就会出现问题(触发Full GC，出现Concurrent Mode Failure)。所以，CMS实际上是在老年代还没有满的时候就开始垃圾收集的，它会留出一部分内存空间在这个回收的时间段内给用户线程使用。HotSpot中默认是老年代的使用率达到92%的时候就开始回收，也可以通过参数来调整这个比例。

如果出现了Concurrent Mode Failure，CMS会临时启用Serial Old收集器进行收集，停顿时间就会很长。

### 标记-清除算法带来的内存碎片

标记-清除算法会带来内存碎片，CMS提供一些参数，可以在每次Full GC的时候触发整理，甚至可以控制经历多少次Full GC就进行一次整理操作。

进行整理操作会导致停顿时间变长。


## CMS的一些参数总结

