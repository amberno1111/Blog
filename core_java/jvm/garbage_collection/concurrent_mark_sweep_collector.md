# CMS垃圾收集器

CMS垃圾收集器，全称Concurrent Mark Sweep Collector，它比较适合具有以下特征的应用场景：

* 重视服务响应速度甚于吞吐量，希望系统停顿时间最短
* 有足够的机器的资源，能够接受垃圾回收线程与应用线程共享处理器资源
* 应用中存在比较多的长生命周期的对象

CMS是基于标记-整理算法的老年代垃圾收集器，它一般和ParNew收集器一起配合使用。设置虚拟机参数`-XX:+UseConcMarkSweepGC`就可以使用CMS垃圾收集器来进行垃圾收集工作，这个时候会默认开启参数`-XX:+UseParNewGC`，即默认使用ParNew对新生代进行垃圾收集工作。

## CMS工作过程

CMS的工作过程如下：

* 初始标记\(initial mark\)
* 并发标记\(concurrent mark\)
* 并发预清理\(cuncurrent pre-clean\)
* 重新标记\(remark\)
* 并发清除\(concurrent sweep\)
* 并发重置\(concurrent reset\)

在CMS的整个工作过程中，只有初始标记和重新标记这两个过程是需要暂停用户线程的，其他三个过程都是可以和用户线程并行运行的。由于垃圾回收的大部分耗时都是在并发标记与并发清除阶段，所以CMS基本上已经把停顿时间降低到最小了，但实际上还是无法完全消除用户线程的停顿时间。

### 初始标记

初始标记过程很简单，速度非常快，耗时也很短。所做的工作就是进行可达性分析，先暂停所有的用户线程，然后标记一下GC Roots能直接关联到的对象\(不包括间接关联的对象\)\(标记过程中会维护一个标记栈，把符合条件的对象存储在标记栈中\)。标记完成之后恢复用户线程。

### 并发标记

这个阶段用户线程和垃圾收集线程可以一起工作，虚拟机会开启多个垃圾收集线程\(默认线程数=\(\(CPU数量\)+3\)/4，或者可以用户自己设置\)进行可达性分析，标记那些GC Roots最终可达的对象。具体做法就是pop标记栈中的对象，然后标记这些对象所直接引用的子对象，把子对象push入标记栈，再继续pop标记栈中的对象，递归的进行如上的操作，直到整个标记栈被清空。

#### 写入屏障

在并发标记阶段，由于用户线程和垃圾线程一起工作，所以肯定会出现并发中常见的同步问题。比如这个场景：A引用B，B引用C，然后当垃圾收集线程把标记完A的所有自对象之后，把A从栈中弹出，垃圾收集线程之后就不会再去遍历A的子对象了。但是这时候如果用户线程的执行逻辑是从B中去掉C的引用，建立A对C的引用。这时候，垃圾收集线程会认为C是不可达的对象\(因为不会再去遍历A了\)，所以C就会被漏标记。

为了解决这个问题，引入了写入屏障\(Write Barrier\)的概念：当改写一个引用的时候，插入一段额外的代码，这段代码保证了当改写引用的时候，会对新引用的对象做一次判断，如果这个对象已经被标记了就什么也不做，继续执行；如果这个对象没有被标记，就把这个对象标记后push到标记栈里。 对应到上面的场景就是：对C进行判断，发现C没有被标记，所以直接把C push到标记栈里，这样就不会漏标记C了。

### 并发预清理

这个阶段是并发执行的，可以通过参数`-XX:-CMSPrecleaningEnabled`关闭，默认是开启的。这个阶段所做的工作，主要是为了减少后续的重新标记的开销。

由于之前的并发标记步骤也是并发执行的，所以可能会产生一些新的老年代垃圾，或者老年代的对象被新生代重新引用，这些对象都是需要重新标记的，主要有以下几种场景：

* 新生代对象晋升到老年代
* 新生代新创建了对象引用了原先老年代未被标记的对象
* 直接在老年代分配的新对象
* 老年代对象的应用关系发生变化

对于场景2来说，垃圾收集器可能需要去扫描整个新生代的对象才能确定老年代中的某些对象是否可以回收。这就会出现一个问题，CMS对老年代进行回收相当于要同时扫描一边新生代和老年代，这个效率就会比较低。

### 重新标记

在并发标记期间，因为垃圾收集线程和用户线程一起工作，用户线程会不断的变更对象引用，此时GC Roots可能会发生变化，重新标记阶段就是为了同步更新这些对象间的引用关系变化，这个更新过程是增量的，所以速度会比并行标记阶段快很多。

重新标记的执行逻辑如下：重新从当前的GC Roots和指针更新的区域出发再进行一次标记。如果是已经标记过的对象，那么会直接跳过。所以重新标记只会遍历那些新增的没有标记过的活动对象和其间有发生引用变化的活动对象，如果引用更新频繁，重新标记有可能会遍历新生代中大部分的甚至全部对象，这时候可以发动一次Minor GC，以减少重新标记的工作量并减少用户线程的停顿时间。

### 并发清除

这个过程就是执行标记-清除算法的过程，一般来说耗时是比较长的，但是可以跟用户线程同时运行。GC线程会遍历整个老年代，遇到没有被标记的对象就清空掉相应的内存块，并把这部分内存块加入可分配列表；遇到被标记的对象，则重置其标记位用于下一次GC，不做其他额外的操作。

### 并发重置

这个阶段主要是一些善后操作，比如重新调整堆的大小，并为下一次GC做好数据结构支持，重置卡表\(card table\)的标位等等。

## 卡表\(card table\)

Minor GC中有一个经典的问题，基本上是所有的垃圾收集器都会遇到的：Minor GC时垃圾回收的目标是只回收新生代中的对象，但是新生代中的对象可能被老年代引用，这样的话进行Minor GC的时候就需要同时扫描新生代和老年代才能确定新生代的哪些对象是可以被回收的。然而扫描老年代是非常耗时的工作，所以CMS使用来一个空间换时间的思路，就是用卡表\(card table\)保存一些数据，以提高扫描老年代的效率。

具体原理如下：老年代内存被划分为一个个大小相等的卡片\(HotSpot默认每个卡片是128个字节\)，然后给每个卡片准备一个对应的标记位，这些卡片的集合就是卡表。当改写对象的引用是从老年代指向新生代时，在老年代对应的卡片标记位上设置标记位即可，被标记了之后的卡片称之为dirty card。这个标记的操作使用了write barrier实现。所以Minor GC时tracing GC Roots的操作就只需要遍历被标记了的卡片上的对象即可，极大的提升了性能。

## GC Log解析

## CMS的缺点

## CMS的一些参数总结

