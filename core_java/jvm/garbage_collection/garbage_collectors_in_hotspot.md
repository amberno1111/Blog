# HotSpot中的垃圾收集器

HotSpot提供了多达7个作用于不同分代的垃圾收集器，如下图所示，如果两个垃圾收集器之间有连线，那么就表示它们之间可以搭配使用。

![Garbage\_Collectors\_in\_HotSpot](https://user-images.githubusercontent.com/16413289/66713157-8d8c9e80-edd9-11e9-8b32-666eebd66244.jpg)

## 垃圾收集算法

在开始介绍垃圾收集器之前，先来看下几种常用的垃圾收集算法，HotSpot中的垃圾收集器都是这些算法的具体实现而已。

### 标记-清除算法

最基础的算法就是标记-清除算法了，因为后面所有的算法，都只是在这个基础上做了一些改进。 标记-清除算法的执行过程分为两步：**首先使用可达性分析算法标记出所有能够回收的对象，在标记完成之后统一回收所有被标记的对象。**

标记-清除算法存在以下问题：

* 效率问题：标记和清除两个过程效率不高
* 空间问题：清除了之后会产生大量不连续的内存碎片，内存碎片过多可能会导致程序在分配大对象时由于找不到足够到的连续内存而提前再触发一次垃圾收集操作

### 复制算法

复制算法解决了标记-清除算法的效率问题。**它将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块内存，然后把已使用过的内存空间一次性清理掉。这样每次都是对一个半区进行回收，内存分配时也不需要考虑内存碎片这种情况，只需要移动堆顶指针，按照顺序分配内存即可。** 这个实现非常简单高效，但是代价有点大，相当于每次都只能使用一半的内存。

现代的商业虚拟机都是采用这种算法来回收新生代的。因为IBM的研究表明，98%的新生代对象都是朝生夕灭的，所以并不需要按照1:1的比例来划分内存空间，而是将内存空间划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor0。当回收的时候，将Eden和Survivr0空间中还存活的对象复制到另一块Survivor1空间中，然后一次性清理掉Eden和Survivor0。当然这里可能会出现Survivor1空间不够的情况，这个时候会有分配担保机制，一般 会把Survivor1无法容纳的新生代对象通过分配担保机制进入老年代。 HotSpot虚拟机默认的Eden和Survivor0大小是8:1，也就是每次新生代中可用内存为整个新生代内存容量的90%，浪费只有10%的内存空间。

复制算法在对象存活率很低的新生代可以很高效，但是在对象存活率很高的老年代，效率就会变的很低。因为需要很多的复制操作，而且内存浪费也会变严重，可用内存和浪费内存的容量比例趋于1:1。

### 标记-整理算法

对于老年代这种对象存活率非常高的区域来说，标记-整理算法更加合适一些。**标记的过程和标记-清除算法是一致的，但是清除的过程不一样。标记-整理算法并不是直接清除对象，而是让所有存活的对象都往一端移动，然后直接清除掉端边界以外的内存。** 这种算法比较好的解决了内存空间碎片的问题。

### 分代收集算法

当前商业虚拟机的垃圾搜集都是采用的分代收集算法，这种算法的思想也很简单，就是根据对象存活周期的不同将内存划分为几块。一般来说是把Java队分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，比如新生代使用复制算法，老年代使用标记-整理算法。

## HotSpot中的垃圾收集器

HotSpot里的垃圾收集器都是上面所介绍的算法的具体实现，由于Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商不同的虚拟机版本所提供的垃圾回收器都会有很大的差别。下面来介绍下JDK1.8版本的HotSpot虚拟机所带有的垃圾收集器。这些垃圾收集器都有各自的优劣以及使用场景，也可以根据使用场景来搭配使用。

### Serial

Serial是一个单线程的收集器\(使用复制算法\)，这里的单线程有两个含义：

* Serial使用来一个线程去做垃圾收集的工作
* Serial工作期间，用户的线程会被暂停运行，只有垃圾收集一个线程在工作，即所谓的`Stop The World`

一般来说，虚拟机只有在运行在client模式下的时候，才会使用Serial作为垃圾收集器，因为这个场景下\(比如桌面软件\)停顿时间\(Stop The World的时间\)基本上能控制在一百毫秒以内，只要不是频繁发生，基本上用户是无感知的。这种场景下，Serial收集器其实是非常简单而高效的。

### ParNew

ParNew收集器是Serial的多线程版本，它的回收策略、收集算法等等都和Serial一摸一样。但是ParNew基本上是大多数运行在Server模式下的虚拟机中首选的新生代收集器，因为只有ParNew能和CMS\(老年代\)收集器搭配使用，而后者被认为是在强交互应用中具有划时代意义的一款垃圾收集器。

当然，ParNew收集器也是有自己的特点的，它在多CPU环境下的表现比Serial更好。ParNew默认开始和CPU核数一样的线程来进行垃圾收集操作，在CPU非常多的场景中，可以使用-XX:ParallelGCThreads参数来限制垃圾回收的线程数。

### Parallel Scavenge

Parallel Scavenge是一个新生代收集器，使用复制算法，也是并行的多线程收集器，看起来和ParNew一摸一样。 但是Parallel Scavenge有一个非常重要的特点，就是它的关注点和其他的收集器不同。ParNew、CMS等收集器的关注点是尽可能的缩短垃圾回收时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是**达到一个可控制的吞吐量。所谓的吞吐量指的是CPU运行用户代码的时间和CPU运行总时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）**。

Parallel Scavenge提供两个参数用于精确的控制吞吐量：

* 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis。不是说把最大垃圾收集停顿时间设置的越小，就可以使得垃圾回收速度越快的。因为GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的，如果这个值设置的过小，可能吞吐量会降低到难以接受的地步。
* 直接设置吞吐量大小的-XX:GCTimeRatio。它的参数值是一个大于0小于100的值，吞吐量是这样计算的：假设GCTimeRatio的值为19，那么吞吐量 = 100% - 1 / \(1+19\) = 95%

Parallel Scavenge另外一个比较有意思的参数是-XX:+UseAdaptiveSizePolicy，设置了这个参数之后，就不需要手工指定新生代的大小，Eden与Survivor区的比例，晋升老年代对象大小等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，然后动态的调整这些参数，**这种调节方式被成为GC自适应的调节策略。**

### Serial Old

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义有两个：

* 给Client模式下的虚拟机使用
* 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用

### Parallel Old

Parallel Old是Parallel Scavenge收集器的老年代版本，这两个收集器可以搭配使用，用于吞吐量优先的场景。Parallel Old使用多线程和标记-整理算法。

### CMS

CMS(Concurrent Mark Sweep)是一款以获取最短停顿时间为目标的老年代垃圾收集器，它非常的适合重视服务响应速度、希望系统停顿时间最短的场景。 CMS是基于标记-整理算法的，它被称为并发低停顿收集器，垃圾收集的部分时间段内，垃圾收集和用户线程能够并发执行，运作过程如下：

* 初始标记：这个过程是需要停顿用户线程的，但是这个过程只是标记一下GC Roots能直接关联到的对象，速度很快，耗时很短
* 并发标记：这是进行GC Roots Tracing的过程，即可达性分析算法执行的过程，这个过程是可以跟用户线程并发执行的，虽然耗时相对来说比较长，但是不影响用户线程的执行
* 重新标记：这个过程是为了修正并发标记期间因用户程序继续运作而导致标记发生变动的那一部分对象的标记记录，这个过程也需要停顿用户线程，耗时一般比初始标记稍长，但是远比并发标记短
* 并发清除：这个过程就是执行标记-清除算法的过程，一般来收耗时时间是比较长的，可以跟用户线程同时进行

  从总体上来说，整个垃圾回收的过程中，耗时最长的并发标记以及并发清除都是能够和用户线程一起工作的，所以CMS垃圾回收器可以把停顿时间减到最小，但是依然没办法完全消除停顿时间。

CMS收集器也存在不少缺点，如下：

* CMS收集器对CPU资源敏感：在并发阶段，虽然CMS可以跟用户线程一起工作，但是因为会有多个垃圾回收线程也在工作，跟用户线程抢占CPU资源，所以也有可能导致用户线程执行变慢。一般CMS默认开启\(CPU + 3\)/4个线程进行垃圾回收操作，所以CPU越多，CMS对应用的运行速度影响越小，在CPU比较少的场景下，就需要考虑下是否适合用CMS收集器了
* CMS收集器无法处理浮动垃圾，可能出现Concurrent Mode Failure失败从而导致另一次Full GC的产生：由于CMS在并发清理阶段的时候，用户线程也在继续进行，也就意味着垃圾在继续产生，这一部分垃圾出现在标记过程之后，所以这一次的垃圾收集操作无法回收这部分垃圾，**这部分垃圾就称之为浮动垃圾\(Floating Garbage\)**。也是因为CMS的并发清理阶段用户线程还需要继续运行，所以CMS不能等到老年代都填满了才开始垃圾收集操作，而是需要预留一部分内存给用户线程使用，这个比例默认是92%，也就是说当老年代的内存使用率达到92%的时候，CMS就开始工作了，这个比例可以通过-XX:CMSInitiatingOccupancyFraction参数来设置。\*\*如果CMS运行过程中所预留的空间无法满足用户线程的需要，就会触发`Concurrent Mode Failure`失败，这时候虚拟机会启动后备预案--临时使用Serial Old收集器来重新进行老年代的垃圾收集，这就会导致停顿时间很长，性能降低明显
* CMS收集器基于标记-清除算法，所以会有内存碎片问题存在：这是标记-清除算法带来的后果，为了减轻内存碎片的影响，CMS提供了-XX:+UseCMSCompactAtFullCollection参数\(默认是开启的\)，这样就会在每次Full GC的时候同时进行一次碎片整理操作。还有一个-XX:CMSFullGCsBeforeCompaction参数可以用于设置执行多少次不进行碎片整理的Full GC操作之后，再进行一次伴随着碎片整理的Full GC

### G1

G1是目前垃圾收集技术最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，具有如下的特点：

* 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来降低应用线程停顿的时间，和CMS一样，G1也可以在垃圾收集的某些阶段实现垃圾收集线程与用户线程同时工作
* 分代收集：与其他收集器一样，分代收集的概念依然在G1中得以保留。G1并不需要其他搜集器配合来管理整个Java堆，它能够采用不同的方式去处理新创建的对象以及存活了一段时间、熬过多次GC的对象。G1将Java堆的内存划分为多个大小相等的独立区域(Region)，而且虽然保留了分代概念，但是新生代和老年代不再是物理隔离的了，他们都是Region的一部分
* 空间整合：G1从整体来看是基于标记-整理算法的，从局部来看(两个Region之间)是基于复制算法实现的。这两种算法都意味着G1运行期间不会有内存碎片的产生
* 可预测的停顿：这是G1相对于CMS的另一大优势，G1除了追求低停顿时间之外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。G1之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。它跟踪各个Region里的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需要时间的经验值)，然后在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

G1收集器的运作大致可以划分为以下几个步骤，很多地方都和CMS类似：

* 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象
* 并发标记：从GC Roots开始对堆中的对象进行可达性分析，找出存活的对象，耗时较长，可以和用户线程一起工作
* 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记发生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里，最终标记完成阶段会把这部分数据合并到Remembered Set中，这个阶段需要停顿用户线程，但是会有多个垃圾收集线程并发执行
* 筛选回收：首先对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间来制定回收计划

