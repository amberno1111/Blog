# Java虚拟机中的对象及其引用

JVM垃圾回收发生在堆和方法区这两个内存区域中，因为这两个区域中的数据，都是在程序运行期间会动态改变的。虚拟机想要对这些数据进行回收，就必须在堆和方法区中搜寻对象，计算对象之间的引用关系，确定对象是否存活，然后根据这些信息来确定当前这个对象是否需要回收。

## 如何判断对象是否存活

判断对象是否存活，目前主流的有引用计数算法与可达性分析算法两种，Java虚拟机采用的是后者。

**引用计数算法**

这是一个比较简单的算法，具体是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效，计数器就减一。任何时刻，计数器为零的对象就是不可能被使用的，可以被安全的回收。

在Python的垃圾回收里，就使用来这种算法。然而在主流的Java虚拟机里，基本上都没有使用引用计数算法。因为引用计数算法很难解决对象之间相互循环引用的问题，比如对象 A 引用了对象 B，同时对象 B 也引用了对象 A，那么他们的引用计数器永远都不可能为零，这两个对象就无法被顺利的回收。

**可达性分析算法**

Java虚拟机是使用可达性分析算法来判断对象是否存活的，这个算法的基本思想是通过把一系列的称之为 *GC Roots* 的对象作为起始点，然后从这些节点向下搜索，搜索经过的路径称为 *引用链*，当一个对象到 *GC Roots* 没有任何引用链相连接(用图论的话来说就是从 *GC Roots* 到这个对象不可达)时，就认为这个对象是不可用的，可以被安全的回收。

在Java语言中，可以作为 *GC Roots* 的对象包括下面几种：
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法中 JNI (Native 方法)引用的对象

实际上在可达性分析算法中的不可达对象，也并非是非回收不可的。一个对象要真正的被回收，至少需要经历两次标记过程。当对象第一次被标记为不可达时，虚拟机会调用这个对象的`finalize()`方法，如果`finalize()`方法中把当前这个对象与另外的对象建立引用连接，就可以变成可达的，这时候就不会被回收。但是，这个`finalize()`只能被执行一次，而且是否立即执行或者执行成功与否，虚拟就都不做保证。所以最好不要使用这个方法，而且这个方法也基本没有什么使用场景。

## 对象的引用

无论是引用计数算法还是可达性分析算法，判断对象是否存活都与对象的引用有关。在Java里，`Reference`类型就是用来表示引用的，它里面存储的数值代表另外一块内存的起始地址。但是Java里的引用除了表示这个对象被引用以及不被引用这两种状态之外，还可以表示更多的状态。
Java将引用分为以下4种，这4种引用强度依次减弱：
- 强引用(Strong Reference)：强引用在代码里很常见，类似于 `A a = new A()`这一类的引用，**只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象**。
- 软引用(Soft Reference)：软引用用于表示一些还有用但并非必须的对象。**对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常**。
- 弱引用(Weak Reference)：弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能存活到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用(Phanton Reference)：虚引用对所关联对象的生命周期没有任何影响，也无法通过一个虚引用来获得一个对象实例。**为一个对象设置虚引用的唯一目的就是能在这个对象被垃圾收集器回收时接收到一个系统通知而已**。

## 方法区的回收

虚拟机规范中说方法区是可以不实现垃圾回收的，因为一般在方法区进行垃圾回收的性价比会比较低。但是常用的 HotSpot 虚拟机还是实现了方法区的垃圾回收。主要回收两部分：**废弃常量和无用的类**。
判定一个常量是否是无用的，比较简单，只需要搜索系统中是否有引用这个常量就好了。
但是判定一个类是无用的类，就比较复杂，一般需要满足以下条件：
- 该类的所有实例都已经被回收
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法