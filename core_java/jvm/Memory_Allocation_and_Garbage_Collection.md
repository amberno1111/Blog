# 内存分配与垃圾回收

Java技术体系中所提倡的内存自动管理可以归结为自动化的解决两个问题：
- 给对象分配内存
- 回收给对象分配的内存

对象的内存分配，基本上就是在Java堆上分配(但也可能经过JIT编译后拆散为标量类型直接在栈上分配)，对象主要分配在新生代的Eden去上，如果启用了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也会直接分配在老年代中，分配规则并不是固定的，其细节取决于具体的垃圾收集器组合以及一些参数配置。

本文会介绍几种比较普遍的内存分配规则。

## 对象优先在Eden区分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机会进行一次`minor GC`。

## 大对象直接进入老年代

所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的是很长的字符串以及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个参数值的对象直接在老年代分配。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存复制(新生代GC使用了复制算法)。

## 长期存活的对象会进入老年代

虚拟机会给每一个对象设置一个对象年龄(Age)，如果对象从Eden区被创建并经历过一次Minor GC后依然存活并且能被Survivor容纳的话，这个对象将会被移动到Survivor区，并且它的年龄被设置为1，对象每多活过一轮Minor GC，年龄就增加一岁。当年龄超过一定限制(默认是15)，就会被晋升为老年代。对象晋升老年代的阈值，可以通过参数-XX:MaxTenuringThreshold设置。

## 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小，如果是，那么就意味着这次Minor GC是没有风险的；如果不是，则虚拟机回去查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，即使这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那就需要进行一次Full GC。

这里的冒险的意思是，新生代垃圾收集使用了复制算法，然后只使用其中一个Survivor空间来作为轮换备份，因此如果出现大对象在Minor GC后依然存活的情况下，Survivor无法容纳整个新生代的对象，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，就意味着老年代需要有这么大的剩余空间。但是在Minor GC发生之前，是不知道具体有多少对象存活的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，从而决定是否进行Full GC来让老年代腾出更多的空间。