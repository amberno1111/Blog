# HotSpot中的Java对象

本文主要探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

## 对象的创建

**Step1:** 当Java虚拟机遇到一条`new`指令时，首先会去方法区的常量池中查找一个类的符号引用，并检查这个符号引用所代表的类是否已经被加载、解析和初始化过。如果没有，则必须先进行类加载的过程。

**Step2:** 在类加载检查成功后，虚拟机会开始为这个对象分配内存。(当一个类被加载成功之后，这个类的实例对象所需要的内存大小已经完全被确定了，具体可以查看后面的章节)。 分配内存就是从Java堆里划出一片内存空间，主要有两种方式：

* 指针碰撞：假设Java堆中的内存是绝对规整的，用过的内存放在一边，没有用过的放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存的时候就可以很简单的把把指针向空闲空间移动和要分配的对象大小一样的内存空间距离就可以了。这叫做指针碰撞。
* 空闲列表：如果Java堆中的内存不是规整的，那Java虚拟机就必须维护一个列表来记录有哪些内存块是可以使用的，在给对象分配内存的时候，就从列表中找出一个足够大的内存块划分给这个对象实例，并且更新列表上的记录。这种方式叫做空闲列表。

具体采用哪种方式来进行内存分配是由Java堆是否规整来决定的，而Java堆是否规整其实收到垃圾收集器的影响。对于Serial、ParNew等带有Compact过程的收集器，系统采用的分配算法是指针碰撞；对于CMS这种基于Mark-Sweep算法的收集器，通常采用空闲列表的方式。

除了如何划分空间之外，分配内存的时候还需要考虑并发的问题。一般采用两种解决方案：

* 对分配内存空间的动作进行同步处理：实际上虚拟机使用的是CAS加上失败重试的方式来保证操作的原子性的。
* 对分配内存空间的动作按照线程分配到不同的空间中进行：给每个线程在Java堆中预先分配一小块内存，称之为**本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)**。采用这种方式之后，同步的开销大大减少，只有在TLAB用完并且需要重新分配TLAB空间的时候才需要同步操作。可以使用`-XX:+/-UseTLAB`参数来设定虚拟机是否使用TLAB。

**Step3:** 内存空间分配完成之后，需要对内存空间进行初始化，全部设置为0(不包括对象头)，如果使用了TLAB则可以在虚拟机给线程分配TLAB空间的时候就全部设置为0。这个操作能够保证对象的实例字段在Java代码中不给初始值就能直接使用，所读到的值是0。

**Step4:** 虚拟机还会对对象进行必要的设置，这个阶段一般都是修改对象的对象头的数据(可以参考对象的内存布局章节)。修改的数据包括：这个对象是哪个类的实例、如何才能找到类的元信息、对象的哈希码、对象的GC分代年龄等信息。

**Step5:** 从虚拟机的角度来看，第上一步结束之后，对象的创建已经完成了。但是对于应用程序来说，还需要执行对象的初始化赋值操作，等初始化操作完成之后，对象才算是真正的创建成功了。

## 对象的内存布局

在HotSpot虚拟机中，对象在内存中的存储布局可以分为三块区域：

* 对象头
* 实例数据
* 对其填充

**对象头：** 对象头的信息也包括两部分：

* 一是对象自身的运行时数据，比如HashCode、GC分代年龄、锁状态标记、线程持有的锁、偏向线程ID等等。这部分数据称之为“Mark Word”。
* 二是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。当然并不是所有的虚拟机实现都必须在对象数据上保留类型指针的，这个可以参见后面的对象的访问定位章节。

ps：另外，如果这个对象是数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的Java对象的元数据信息确定对象的大小，但是从数组的元数据信息无法确定数组的大小。

**实例数据：** 实例数据就是对象真正存储的有效信息，也是程序代码中所以定义的各种类型的字段内容。

**对其填充：** 这部分数据不一定存在，它起着占位符的作用。因为HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。但是真实的对象数据大小不一定是8的整数倍，这个时候就需要使用对其填充来起到补全的作用。

## 对象的访问定位

Java程序需要通过栈上存储的对象数据引用(reference)来操作存储在堆上的对象实例。由于reference类型在Java虚拟机规范中只是规定了一个指向对象的引用，并没有定义这个引用应该使用何种方式区定位、访问堆中的对象的具体位置，对于对象的访问方式是取决于具体的虚拟机实现的。

目前主流的访问方式有两种：

**使用句柄：** 如果使用句柄访问的话，Java堆中将会划分出一块内存作为句柄池，reference对象中存储的就是对象的句柄地址，然后句柄中包含了到对象实例数据的指针(这个指针指向堆中实例池里存储的具体实例对象数据)_以及到对象类型数据的指针(这个指针指向方法区中存储的类的数据)。 使用这种方法的好处是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时会移动对象)时只会改变句柄中的实例数据指针，而reference本身不需要改变。

**直接指针：** 使用直接指针就比较简单一些，reference中存储的是直接对象的地址，直接对象的数据中存储了对象实例数据，也存储了对象类型数据的指针。 使用这种方法的好处是速度快，它节省了一次指针定位的时间开销。HotSpot就是采用这种方式进行对象访问的。

