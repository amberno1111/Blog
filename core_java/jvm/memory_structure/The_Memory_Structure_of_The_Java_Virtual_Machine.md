# Java虚拟机内存区域

Java虚拟机在运行的时候，把它所管理的内存划分成了若干个不同的数据区域。这些区域各有各的用途，它们的生命周期也各不相同。这些区域如下图所示：

![JVM_memory_model](https://user-images.githubusercontent.com/16413289/65386396-c94dbe80-dd6d-11e9-85b5-6f97cb0e7569.png)

其中：
- 方法区和堆是所有线程共享的
- 虚拟机栈、本地方法栈、程序计数器都是线程私有的

我们一个一个的来了解这些内存区域。

## 方法区

方法区是各个线程共享的内存区域，它被用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它有一个别名叫non-heap。

运行时常量池也是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将会在类加载后存放到运行时常量池中。

字面量：字面量是指Java语言层面的常量，比如文本字符串、被声明为final的常量值等等。

符号引用：这是编译原理相关的概念，包括以下三种常量：
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

## 堆

Java堆是Java内存管理的核心区域，它是在虚拟机启动的时候创建的，被所有的线程共享，主要用来存放对象实例，几乎所有创建的Java对象都是直接分配在堆上。(但是随着JIT编译器的发展以及逃逸分析技术的逐渐成熟，栈上分配、标量替换等优化技术可能会导致一些对象实例并不分配在堆上)。

堆是垃圾收集器管理的主要区域，所有堆会被细分为老年代、新声代区域等等。

## 虚拟机栈

虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译期间可知的各种基本数据类型、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象其实地址的引用指针，也可能是指向一个代表对象句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。

## 本地方法栈

本地方法栈与虚拟机栈的作用非常类似，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的Native方法服务。在Oracle Hotspot JVM中，本地方法和Java虚拟机栈是在同一块区域，这完全取决于技术实现，并未在JVM规范中强制。

## 程序计数器

每个线程都有独立的程序计数器，并且任何时间一个线程都只有一个方法在执行，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，这个计数器的值则为空(Undefined)。

## 直接内存

直接内存并不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域。但是Java会使用到这部分内存，在NIO中引入了一种基于Channel和缓冲区的I/O方式，它使用Native函数直接分配堆外内存，然后通过一个存储在Java堆内的DirectByteBuffer对象作为这块内存的引用进行操作，这样可以在一些场景中显著的提高性能，因为避免了在Java堆和Native堆中来回copy数据。