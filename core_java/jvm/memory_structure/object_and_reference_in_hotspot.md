# Java虚拟机中的对象与引用

JVM 垃圾回收发生在堆和方法区这两个内存区域中，因为这两个区域中的数据，都是在程序运行期间会动态改变的。虚拟机想要对这些数据进行回收，就必须在堆和方法区中搜寻对象，计算对象之间的引用关系，确定对象是否存活，然后根据这些信息来确定当前这个对象是否需要回收。

## 如何判断对象是否存活

判断对象是否存活，目前主流的有引用计数算法与可达性分析算法两种，Java虚拟机采用的是后者。

### 引用计数算法

这是一个比较简单的算法，具体是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效，计数器就减一。任何时刻，计数器为零的对象就是不可能被使用的，可以被安全的回收。

在 Python 的垃圾回收里，就使用来这种算法。然而在主流的 Java 虚拟机里，基本上都没有使用引用计数算法。因为引用计数算法很难解决对象之间相互循环引用的问题，比如对象 A 引用了对象 B，同时对象 B 也引用了对象 A，那么他们的引用计数器永远都不可能为零，这两个对象就无法被顺利的回收。

### 可达性分析算法

Java虚拟机是使用可达性分析算法来判断对象是否存活的，这个算法的基本思想是通过把一系列的称之为 **GC Roots** 的对象作为起始点，然后从这些节点向下搜索，搜索经过的路径称为**引用链**，当一个对象到 GC Roots 没有任何引用链相连接(用图论的话来说就是从 GC Roots 到这个对象不可达)时，就认为这个对象是不可用的，可以被安全的回收。

在 Java 语言中，可以作为 GC Roots 的对象包括下面几种：

* 虚拟机栈(栈帧中的本地变量表)中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法中 JNI (Native 方法)引用的对象

实际上在可达性分析算法中的不可达对象，也并非是非回收不可的。一个对象要真正的被回收，至少需要经历两次标记过程。当对象第一次被标记为不可达时，虚拟机会调用这个对象的`finalize()`方法，如果`finalize()`方法中把当前这个对象与另外的对象建立引用连接，就可以变成可达的，这时候就不会被回收。但是，这个`finalize()`只能被执行一次，而且是否立即执行或者执行成功与否，虚拟就都不做保证。所以最好不要使用这个方法，而且这个方法也基本没有什么使用场景。

### HotSpot实现的可达性分析算法

**枚举根结点** 可达性分析算法的第一步就是需要找出所有的 GC Roots 节点，但是这些节点分布在全局性的引用(例如常量或者类静态属性)与执行上下文中(栈帧中的本地变量表)，如果每次都全局扫描一遍，时间复杂度会非常高。 另外，可达性分析对于执行时间非常敏感，因为这个分析的操作必须在一个能够确保“一致性”的快照中进行 - 这里的一致性指的是在分析期间，整个系统看起来就像暂停了一样，对象引用关系在这个时间段内不会发生变化。为了保证这一点，目前所有的 Java 虚拟机在进行 GC 的时候，都需要暂停所有的 Java 执行线程。

HotSpot 的实现中使用了 OopMap 来保证寻找 GC Roots 的效率：在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样GC在扫描的时候，只需要从扫描OopMap就可以获取 GC Roots 了。

**安全点** 虽然OopMap可以保存栈和寄存器中哪些位置是引用的信息，但是虚拟机肯定不可能给每一条指令都生成 OopMap，这样的话空间复杂度会非常高。所以 HotSpot 只会在“特定的位置”记录下这些信息，这些特定的位置称之为**安全点(Safepoint)**，也就是说并非在程序运行的任意地方都能停顿下来进行 GC，只有程序运行到安全点才能进行暂停并进行 GC。 安全点的选择是以“是否能让程序有长时间执行的特征”为标准选定的，比如方法调用、循环跳转、异常跳转等，在这些地方进行垃圾回收的性价比最高。

另外还有一个问题就是，HotSpot 需要让程序在安全点暂停。一般有两种做法：

* 抢先式中断：在 GC 发生时，首先把所有的线程中断，如果发现有被中断的线程不处于安全点上，就唤醒线程，让它跑到安全点上。这种方式很难控制，所有基本上没有虚拟机会采用。
* 主动式中断：HotSpot 使用的是这种方式，当GC需要中断线程的时候，不直接对线程进行操作，仅仅是简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的。这种做法需要编译器的配合，在指定的地方插入轮询的指令。

**安全区域** Safepoint 机制保证了线程运行了不太长的时间内就能遇到一个可 GC 的 Safepoint ，但是如果线程当前处于 sleep 或者 blocked 状态的时候，线程是无法相应 JVM 的中断请求的。这种情况，就需要 **安全区域(Safe Region)** 来解决。 安全区域是指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意一个地方开始 GC 都是安全的。 线程在执行 Safe Region 中的代码时，首先标志自己已经进入 Safe Region，这样在这段时间里虚拟机发起 GC 的时候，就不需要管已经标记为进入 Safe Region 的线程了。在线程离开 Safe Region 时，需要检查系统是否已经完成了根结点枚举，如果完成了，线程就继续执行；如果没完成，就必须等待直到收到可以离开 Safe Region 的信号为止。

## 对象的引用

无论是引用计数算法还是可达性分析算法，判断对象是否存活都与对象的引用有关。在Java里，`Reference`类型就是用来表示引用的，它里面存储的数值代表另外一块内存的起始地址。但是Java里的引用除了表示这个对象被引用以及不被引用这两种状态之外，还可以表示更多的状态。 Java将引用分为以下4种，这4种引用强度依次减弱：

* 强引用(Strong Reference)：强引用在代码里很常见，类似于 `A a = new A()`这一类的引用，**只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象**。
* 软引用(Soft Reference)：软引用用于表示一些还有用但并非必须的对象。**对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常**。
* 弱引用(Weak Reference)：弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能存活到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* 虚引用(Phanton Reference)：虚引用对所关联对象的生命周期没有任何影响，也无法通过一个虚引用来获得一个对象实例。**为一个对象设置虚引用的唯一目的就是能在这个对象被垃圾收集器回收时接收到一个系统通知而已**。

## 方法区的回收

虚拟机规范中说方法区是可以不实现垃圾回收的，因为一般在方法区进行垃圾回收的性价比会比较低。但是常用的 HotSpot 虚拟机还是实现了方法区的垃圾回收。主要回收两部分：**废弃常量和无用的类**。 判定一个常量是否是无用的，比较简单，只需要搜索系统中是否有引用这个常量就好了。 但是判定一个类是无用的类，就比较复杂，一般需要满足以下条件：

* 该类的所有实例都已经被回收
* 加载该类的 ClassLoader 已经被回收
* 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

