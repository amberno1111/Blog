# 虚拟机类加载机制

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、解析以及初始化。这些数据会被放在运行时数据区的方法区内，然后在堆内创建一个`java.lang.Class`对象，这个对象封装了类在方法区内的数据，并且提供类访问方法区内数据的接口。
这整个过程叫做虚拟机的类加载机制。

## 类的生命周期

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括7个阶段：加载、验证、准备、解析、初始化、使用、卸载。

其中：
- 验证、准备、解析这三个阶段称之为连接
- 除了解析阶段，其他的步骤开始顺序都是确定的，下一个阶段的开始肯定在上一个阶段的开始之后，但是不一定在上一个阶段的结束之后，有可能在之前。而解析就不一样了，它可能在初始化之后开始，这是为了支持Java语言的运行时绑定而做的

## 类加载的时机

虚拟机在什么时候会开始加载类呢？虚拟机规范其实没有对这个进行强行的规定，它只是对**初始化**这个阶段的开始时刻进行类强制规定，有且只有在以下五种情况下必须马上对类进行初始化(而启动加载类的程序自然在初始化之前)：
- 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条指令的时候如果发现类没有被初始化，则必须先触发其初始化
- 使用Java反射包调用某个class的时候，如果发现类没有被初始化，则必须先触发其初始化
- 当初始化一个类的时候，发现其父类没有被初始化，则需要先触发其父类的初始化
- 当虚拟机启动的时候，用户需要指定一个主类，虚拟机会先初始化这个主类
- 当使用JDK1.7的动态类型语言支持的时候，中间可能会需要触发一些类的初始化


除了上面五种情况之外，所有引用类的方式都不会进行初始化，称之为被动引用。

举几个例子：

```java
public class A {
    public static final String A_VALUE = "aaa";
}
public class B {
    public String getValue() {
        return A.A_VALUE + B.getClass();
    }
}
// 当调用 B 的 getValue 方法时，不会初始化 A
// 因为在编译的过程中，B 这个 class 里的 A_VALUE 这个常量被替换成了 "aaa"
// 然后相当于 B 并没有引用 A

```

```java
public class ParentClass {
    public static int value = 123;
}
public class SubClass extends ParentClass {

}

public class Test {
    public int getValue() {
        return SubClass.value;
    }

}

// 这个时候实际上不会初始化 SubClass，只会初始化 ParentClass
```


## 类加载过程完整介绍

接下来介绍下加载、验证、准备、解析、初始化这五个类加载的核心过程。

### 加载

加载主要做三件事情：
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在堆中生成一个`java.lang.Class`对象，作为这个类在方法区的各种数据的访问入口

加载class的方式也有很多：
- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip，jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件

数组的加载会有些不同，数组类本身不是通过类加载器创建的，是通过Java虚拟机直接创建的，但是数组加载的时候，还是会需要用到类加载器，因为数组的元素类型最终是要靠类加载器去创建的。

加载开始之后，后面的连接阶段就会开始，这两个阶段交替进行。

相对于其他阶段而言，加载阶段是可控性最强的阶段，可以自定义类加载器进行加载。

### 连接

#### 验证：确保被加载的类的正确性

这一阶段的目的是为了保证Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，大致上会完成下面4个阶段的验证工作：
- 文件格式验证：验证字节流是否符合Class文件格式的规范，比如是否以指定的魔法数开头，class文件里里的版本信息等等
- 元数据验证：对字节码的描述的信息进行语义分析，保证Class文件描述的信息符合Java语言规范
- 字节码验证：通过数据流和控制流分析，确定程序的语义是合法的，符合逻辑的
- 符号引用验证：对类自身以外的信息进行匹配性校验，比如检查这个类引用的其他Class能否通过全限定名找到等等


#### 准备：为类的静态变量分配内存，初始化为默认值

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
- 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
- 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值

#### 解析：把类中的符号引用转换为直接引用

符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够无歧义的定位到目标即可。

直接引用：可以是指向目标的指针、相对偏移量、或者一个能间接定位到目标的句柄。如果有来直接引用，那么引用的目标必定在内存中已经存在。

解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄、和调用限定符7类符号引用进行。

### 初始化

这个阶段给类的静态变量赋予正确的初始值。

## 类加载器

虚拟机设计团队把类加载阶段的**通过一个类的全限定名来获取描述此类的二进制字节流**的动作放到Java虚拟机之外来实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为**类加载器**。


### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，即：只有在两个类都来自于同一个Class文件，并且它们的类加载器都是相同的情况下，才能被认为这两个类是**相等的**。


### 双亲委派模型

对于JVM来说，类加载器分为两类：
- 启动类加载器：这个类加载器是使用C实现的，是虚拟机的一部分。它负责加载存放在`JAVA_HOME\lib`目录中的，或者被`-Xbootclasspath`参数所指定的路径中的，或者被虚拟机识别的类库加载到虚拟机内存中。如果用户想要把加载请求委派给启动类加载器，只需要直接使用null代替即可
- 其他类加载器：这些加载器由Java语言实现，独立于虚拟机外部，并且全部都继承抽象类`java.lang.ClassLoader`

其他的类加载器可以细分：
- 扩展类加载器：用于加`JAVA_HOME\ext`目录中的或者被`java.ext.dirs`系统变量所指定的路径中的所有类库
- 应用程序类加载器：这是默认的系统类加载器，负责加载用户类路径(ClassPath)所指定的类库。


这些加载器之间的层次关系如下，这种层次关系称之为**双亲委派模型**：

![image](https://user-images.githubusercontent.com/16413289/69133698-4d63be80-0af1-11ea-9609-67b82620cb0f.png)

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的加载器不会使用继承的方式，而是使用组合的方式来实现的。

双亲委派模型的工作过程如下：
- 假设应用程序类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器(扩展类加载器)去完成
- 扩展类加载器也不会自己去尝试加载这个类，而是把这个请求委派给启动类加载器去完成，然后启动类加载器加载类失败，则通知扩展类加载器去加载
- 扩展类加载器再加载失败，则通知应用程序类加载器去加载，如果失败，则抛出异常

这个流程中间，只要有一个加载成功，这个类就可以加载成功了。

使用双亲委派模型的好处是可以保证Java程序安全稳定的运行：防止用户写跟rt.jar中的类同样的Java类，然后加载它(比如Object类)，如果出现这种情况，会导致Java的基础模型遭到破坏(Java所有的对象都应该是rt.jar中的Object类的子类)。使用类双亲委派模型的话，至始至终都能确定只有使用了rt.jar中的Object class以及启动类加载器加载出来的Object对象才是真正正确的Object对象。

之前遇到过一个class加载错误的线上故障，就是因为双亲委派模型机制导致的，同一个类出现在多个Jar包中(实际上是依赖了同一个Jar包的不同版本)，由于在双亲委派类加载机制下，加载该Jar包的类加载器层级越高，该Jar包越先被加载，它所包含的Class越先被执行。而新版的Jar包里的某个Class是自定义的类加载器加载的，这个自定义加载器的实现上是作为应用程序类加载器的下一层级，而旧版的Jar包里的这个Class是直接使用应用程序类加载器加载的。出现的结果就是每次都加载了旧版本的Class。

### 线程上下文类加载器



### 使用类加载器的场景




